<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL Stack Queue Deque PriorityQueue Pair</title>
    <url>/2022/04/14/C++STL/</url>
    <content><![CDATA[<h1 id="C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）"><a href="#C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）" class="headerlink" title="C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）"></a>C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack:"></a>Stack:</h2><p>头文件：</p>
<p><code>#include&lt;stack&gt;</code></p>
<p>简介：</p>
<p>stack（栈），是一种后进先出（Last-In-First-Out，LIFO）的线性结构，支持两种操作：push和pop。</p>
<p>push操作是把一个元素加入栈中，pop操作是把最晚进入的元素删除。</p>
<span id="more"></span>

<p>常用的member function：</p>
<p>empty()：空则返回true。</p>
<p>size()：返回当前stack中有多少元素。</p>
<p>push()：在stack中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p>
<p>pop()：移除顶层元素，如果为空则发生Runtime Error。</p>
<p>top()：返回最上层的reference。如果为空，则发生Runtime Error。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure>



<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h2><p>头文件：</p>
<p><code>#include&lt;queue&gt;</code></p>
<p>简介：</p>
<p>Queue（队列），是一种先进先出（FIFO）的线性结构，虽然习惯上称为enqueue和dequeue，但是在STL中名称为push和pop。</p>
<p>常用的member function：</p>
<p>empty()：空则返回true。</p>
<p>size()：返回当前queue中有多少元素。</p>
<p>push()：在queue中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p>
<p>pop()：移除最前端元素，如果为空则发生Runtime Error。</p>
<p>front()：返回最前端的reference。如果为空，则发生Runtime Error。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure>



<h2 id="Deque："><a href="#Deque：" class="headerlink" title="Deque："></a>Deque：</h2><p>头文件：</p>
<p><code>#include&lt;deque&gt;</code></p>
<p>简介：</p>
<p>Deque（双端队列，Double-ended queue，念作“deck”，勿与dequeue混淆），线性结构，支持四种基本操作：push，inject，pop，eject。</p>
<p>Push操作是把一个元素加入deque的前端，inject操作是把一个元素加入deque的猴拳；pop操作是把deque最前端的元素移除，eject操作是把的却最后全的元素移除。</p>
<p>注：我们都还是喜欢将push_front、push_back、pop_front、pop_back，并且在STL的名称亦是如此。</p>
<p>常用的member function：</p>
<p>empty()：空则返回true。</p>
<p>size()：返回当前deque中有多少元素。</p>
<p>push_front()：在deque前端中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p>
<p>push_back()：在deque后端中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p>
<p>pop_front()：移除deque最前端元素，如果为空则发生Runtime Error。</p>
<p>pop_back()：移除deque最后端元素，如果为空则发生Runtime Error。</p>
<p>front()：返回最前端的reference。如果为空，则发生Runtime Error。</p>
<p>back()：返回最后端的reference。如果为空，则发生Runtime Error。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; de;</span><br><span class="line">de.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>



<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue:"></a>PriorityQueue:</h2><p>头文件：</p>
<p><code>#include&lt;queue&gt;</code></p>
<p>简介：</p>
<p>PriorityQueue（优先队列），是一种按照优先程度来排列的结构，支持两种操作：push和pop。</p>
<p>push是把一个元素加入队列中，pop是把优先顺序最高的元素移除。</p>
<p>常用的member function：</p>
<p>empty()：空则返回true。</p>
<p>size()：返回当前有多少元素。</p>
<p>push()：在queue中加入一个元素。注意，被加入的元素会复制一份，而非Reference。</p>
<p>pop()：移除优先顺序最高的元素，如果为空则发生Runtime Error。</p>
<p>front()：返回优先顺序最高元素的constant reference。如果为空，则发生Runtime Error。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">pq.<span class="built_in">push</span>(i);</span><br></pre></td></tr></table></figure>

<ul>
<li>priority_queue<T> pq; 预设由大排到小</li>
<li>priority_queue&lt;T, **vector**<T>, <strong>greater</strong><T> &gt; pq; 改成由小排到大</li>
<li>priority_queue&lt;T, **vector**<T>, <strong>cmp</strong>&gt; pq; 自定义 cmp 排序</li>
</ul>
<p>自定义cmp：使用struct（overload operator()）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair:"></a>Pair:</h2><p>头文件：</p>
<p><code>#include&lt;utility&gt;</code></p>
<p>将两个元素绑在一起，第一个元素为first，第二个元素为second。</p>
<h2 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h2><p>C风格字符串复制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">myList</span>(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//初始化为5个10</span></span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">4</span>);<span class="comment">//最后插入</span></span><br><span class="line">mylist.<span class="built_in">push_front</span>(<span class="number">0</span>);<span class="comment">//最前插入</span></span><br><span class="line">mylist.<span class="built_in">pop_back</span>();<span class="comment">//最后删除</span></span><br><span class="line">mylist.<span class="built_in">pop_front</span>();<span class="comment">//最前删除</span></span><br><span class="line">mylist.<span class="built_in">front</span>();<span class="comment">//获得求前面的元素</span></span><br><span class="line">mylist.<span class="built_in">back</span>();<span class="comment">//获得最后面的元素</span></span><br><span class="line"><span class="built_in">reverse</span>();<span class="comment">//反转</span></span><br><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(iterator pos,value_type val)</span></span>;<span class="comment">//在指定位置插入，并且链表的大小增加1</span></span><br><span class="line"><span class="comment">//等等</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>VLAN</title>
    <url>/2022/05/22/VLAN/</url>
    <content><![CDATA[<h2 id="1-为什么需要VLAN"><a href="#1-为什么需要VLAN" class="headerlink" title="1. 为什么需要VLAN"></a>1. 为什么需要VLAN</h2><p>需要将网络分割成多个广播域，减少网络带宽和CPU算力的大量无谓消耗。</p>
<p>在网络中，广播帧回非常频繁地出现，除了ARP之外，还有DHCP、RIP等很多其他类型的广播信息。</p>
<p>ARP请求：建立IP和MAC地址的映射关系。</p>
<p>RIP： Routing Information Protocol，路由信息协议，采用距离向量计算。</p>
<p>DHCP：用于自动设定IP地址的协议。</p>
<p>通常情况下，路由器上不会有太多的网络接口，其数目多在1~4个左右。随着宽带连接的普及，宽带路由器（或者叫IP共享器）变得较为常见。但需要注意的是，它们上面虽然带着多个（一般为4个）连接LAN一侧的网络接口，但那其实是路由器内置的交换机，并不能分割广播域。</p>
<p>况且使用路由器分割广播域的话，所能分割的个数完全取决于路由器的网络接口个数，使得用户无法自由地根据实际需要分割广播域。</p>
<p>与路由器相比，二层交换机一般带有多个网络接口。因此如果能使用它分割广播域，那么无疑运用上的灵活性会大大提高。</p>
<p>用于在二层交换机上分割广播域的技术，就是VLAN。通过利用VLAN，我们可以自由设计广播域的构成，提高网络设计的自由度。</p>
<h2 id="2-实现VLAN的机制"><a href="#2-实现VLAN的机制" class="headerlink" title="2. 实现VLAN的机制"></a>2. 实现VLAN的机制</h2><p>在一台未设置任何VLAN的二层交换机上，任何广播帧都会被转发给除接收端口外的所有其他端口（Flooding）。</p>
<p>这是如果将端口配置不同的VLAN，这样在转发的时候就只会转发给特定VLAN端口，分割了广播域。在实际使用中，不同VLAN用“VLAN ID”来区分。</p>
<p>在交换机上设置VLAN，可以看作将一台交换机换做多台虚拟的交换机，这些逻辑上的交换机是互不相通的。因此，在交换机上设置VLAN后，如果为做其他处理，VLAN间是<strong>无法通信</strong>的。</p>
<p>那么，如果需要在不同的VLAN间通信时又该怎么办呢？</p>
<p>请注意一下，VLAN是广播域，而通常两个广播域之间由路由器连接，广播域之间来往的数据包都是由路由器中继的。因此，VLAN间的通信也需要路由器提供中继服务，这被称作“VLAN间路由”。VLAN间路由可以使用普通的路由器，也可以使用三层交换机。</p>
<h2 id="3-VLAN的访问链接（Access-Link）"><a href="#3-VLAN的访问链接（Access-Link）" class="headerlink" title="3. VLAN的访问链接（Access Link）"></a>3. VLAN的访问链接（Access Link）</h2><p>交换机的端口，可以分成一下两种：</p>
<ul>
<li>访问链接（Access Link）</li>
<li>汇聚链接（Trunk Link）</li>
</ul>
<h3 id="访问链接"><a href="#访问链接" class="headerlink" title="访问链接"></a>访问链接</h3><p>访问链接，指的是“只属于一个VLAN，且仅向该VLAN转发数据帧”的端口。在大多数情况下，访问链接所连的是客户机。</p>
<p>通常设置VLAN的顺序是：</p>
<p>（1）生成VLAN</p>
<p>（2）设定访问链接（决定各端口属于哪一个VLAN）</p>
<p>设定</p>
<p>访问链接的手法，可以是事先固定的，也就是静态VLAN，也可以是根据所连计算机而动态改变设定，也就是动态VLAN。</p>
<h4 id="静态VLAN–基于端口"><a href="#静态VLAN–基于端口" class="headerlink" title="静态VLAN–基于端口"></a>静态VLAN–基于端口</h4><p>静态VLAN又被称为基于端口的VLAN（PortBased VLAN）。顾名思义，就是明确指定各端口所属的VLAN的设定方法。</p>
<h4 id="动态VLAN"><a href="#动态VLAN" class="headerlink" title="动态VLAN"></a>动态VLAN</h4><p>动态VLAN是根据每个端口所连的计算机，随时改变端口所属的VLAN。动态VLAN大致分为3类：</p>
<ul>
<li>基于MAC地址的VLAN（MAC Based VLAN）（第二层）</li>
<li>基于子网的VLAN（Subnet Based VLAN）（第三层）</li>
<li>基于用户的VLAN（User Based VLAN）（第四层以上）</li>
</ul>
<p>其间的差异，主要在于根据OSI参照模型哪一层的信息决定端口所属的VLAN。</p>
<h2 id="4-VLAN的汇聚链接"><a href="#4-VLAN的汇聚链接" class="headerlink" title="4. VLAN的汇聚链接"></a>4. VLAN的汇聚链接</h2><p>当需要设置多台交换机的VLAN时，即每个用户分散在较远的地方，这时候就需要考虑如何跨越多台交换机设置VLAN的问题了。当然，可以在交换机的端口中新开出VLAN端口，将两台交换机的端口相连（类似于串联），但是这个方法从扩展性和管理效率来看都不好，VLAN越多，交换机间所需链接的端口就越多，对端口的利用率下降，布线也可能需要调整，限制了网络的扩展。</p>
<p>为了避免这种低效率的连接方式，人们想办法让交换机间互联的网线集中到一根上，这时候使用的就是汇聚链接（Trunk Link）。</p>
<p>汇聚链接（Trunk Link）就是指能够转发多个不同VLAN通信的端口。汇聚链路上流通的数据帧，都被附加了用于识别分别属于哪个VLAN的特殊信息。网线使用普通的UTP线，交换机间互联使用交叉线。</p>
<p>通过汇聚链路时附加的VLAN识别信息，有可能支持标准的“IEEE 802.1Q”协议，也可能时Cisco独有的协议。在设定汇聚链接时，有一个前提就是必须支持100Mbps以上的传输速度。</p>
<p>在默认条件下，汇聚链接会转发交换机上存在的所有VLAN数据，为了减轻交换机的负担，同时也为了减少对带宽的浪费，可以通过用户设定限制能够经由汇聚链路互联的VLAN。</p>
<h2 id="5-VLAN间路由"><a href="#5-VLAN间路由" class="headerlink" title="5. VLAN间路由"></a>5. VLAN间路由</h2><p>两台计算机即使连接在同一台交换机上，只要所属的VLAN不同，就无法通信。这是因为LAN内的通信必须在数据帧头部指定通信目标的MAC地址，而为了获取MAC地址，TCP&#x2F;IP协议下使用的是ARP。ARP解析MAC地址的方法是通过广播，也就是说，如果广播报文无法到达，那么久无从解析MAC地址，亦无法直接通信。</p>
<p>为了能在VLAN间通信，需要利用OSI参照模型中更高一层——网络层的信息（IP地址）来进行路由。</p>
<h3 id="使用路由器进行VLAN间路由"><a href="#使用路由器进行VLAN间路由" class="headerlink" title="使用路由器进行VLAN间路由"></a>使用路由器进行VLAN间路由</h3><p>在使用路由器进行VLAN间路由时，与构建横跨多台交换机的VLAN时的情况类似，我们还是会遇到“该如何连接路由器与交换机”这个问题。路由器和交换机的接线方式，大致有以下两种：</p>
<p>(1)将路由器与交换机上的每个VLAN分别连接</p>
<p>(2)不论VLAN有多少个，路由器与交换机都只用一条网线连接</p>
<p>如果将路由器与交换机上的每个VLAN分别连接，将交换机上用于和路由器互联的每个端口设为访问链接（Access Link），然后分别用网线与路由器上的独立端口互联。这样扩展性会有问题。</p>
<p>当只用一条网线连接时，需要用到汇聚链接（Trunk Link），而路由器上的端口也必须支持汇聚链路，协议必须相同。</p>
<p>相同VLAN中两台主机的通信可能不经过路由器，进行VLAN间的通信，即使通信双方都连接在同一台交换机上，也必须经过：“发送方–交换机–路由器–交换机–接收方”这样一个流程。</p>
<p>三层交换机的内容略。</p>
<h2 id="6-使用VLAN设计局域网"><a href="#6-使用VLAN设计局域网" class="headerlink" title="6.使用VLAN设计局域网"></a>6.使用VLAN设计局域网</h2><p>略。</p>
<p><a href="https://zhuanlan.zhihu.com/p/35616289">VLAN 基础知识 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>交换机</tag>
      </tags>
  </entry>
  <entry>
    <title>STP协议</title>
    <url>/2022/05/22/STP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>STP（Spanning Tree Protocol，生成树协议）是数据链路层的管理协议，发送BPDU帧，通过有选择性地阻塞网络冗余链路来达到消除网络环路地目的，同时具有链路冗余备份地功能。</p>
<span id="more"></span>
<p><a href="http://www.360doc.com/content/22/0410/08/73220646_1025683071.shtml">http://www.360doc.com/content/22/0410/08/73220646_1025683071.shtml</a><br><a href="https://baijiahao.baidu.com/s?id=1717844500187898757&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1717844500187898757&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
        <tag>交换机</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP与OSPF</title>
    <url>/2022/05/21/RIP%E4%B8%8EOSPF/</url>
    <content><![CDATA[<p>计算机网络课程总结–RIP与OSPF<a href="https://wulc.me/2016/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--RIP%E4%B8%8EOSPF/">https://wulc.me/2016/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--RIP%E4%B8%8EOSPF/</a></p>
<span id="more"></span>

<h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>路由信息协议（Routing Information Protocol，RIP）是一种采用距离向量算法的路由协议。</p>
<p>到目的网络的距离以跳为但是，最大距离为15，距离16表示无穷大，即目的网络不可达。正式这一规定限制了RIP的适用范围，是RIP局限于小型的局域网络中。</p>
<p>初始时每个RIP路由器只有到直连网的路由，他们的距离为1。每30sRIP路由器把它的整个路由表发送给邻居，具体实现时每个邻居会错开发送，30s的时间也会随机变化一点。当收到邻居发来的路由表（update packet），路由器将更新它的路由表&lt;目的网络，开销，下一跳&gt;：</p>
<p>（1）收到的路由的距离全部加1</p>
<p>（2）利用上述路由修改路由表：</p>
<ul>
<li>把路由表中不存在的路由加入路由表。</li>
<li>如果比路由表中的路由距离更小，则更新该路由的距离为新距离，并把下一跳改为邻居。</li>
<li>如果路由存在，就要重置失效定时器。</li>
</ul>
<p>RIP路由表中每一项都有TTL（Time-To-Live），用失效定时器（invalid timer）计时，超时则让该路由失效。</p>
<h2 id="RIP协议的问题"><a href="#RIP协议的问题" class="headerlink" title="RIP协议的问题"></a>RIP协议的问题</h2><p>慢收敛问题（slow convergence）：</p>
<p><img src="https://img-blog.csdn.net/2018062420065145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L04xbmVEaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>慢收敛是RIP相对于OSPF而言的，就是RIP依靠定时器进行30s一次的周期更新路由器的路由表，但当网络拓扑结构发生变化时，它收敛于新拓扑的速度慢，就有可能导致环路的产生，使错误数据重复发送。</p>
<h2 id="RIP协议的技术"><a href="#RIP协议的技术" class="headerlink" title="RIP协议的技术"></a>RIP协议的技术</h2><p>1.水平分割技术（split horizon）：从一个接口学来的路由不会从该接口发回去。</p>
<p>2.毒性反转技术（poison reverse）：当一条路由变为无效之后，路由器并不立即将它从路由表中删除，而是将其距离改为16之后广播给邻居，使邻居所拥有的该路由器立即失效，而不是等待TTL到期后删除，以迅速消除路由环路，这种方法称为毒性反转，距离为16的路由称为毒化路由（poisoned route）。</p>
<p>3.抑制技术（hold down）：距离被改为无穷大的路由在一段时间（180s）内其距离不允许被修改。</p>
<p>4.触发更新（trigger update）：一旦出现路有变化将立即把增加或更新的路由发送给邻居。原有的30s发一次完整的路由表依然不变。</p>
<h2 id="RIP计时器"><a href="#RIP计时器" class="headerlink" title="RIP计时器"></a>RIP计时器</h2><ol>
<li><p>更新定时器（update timer）控制一个路由器如何定期把路由表发送给邻居。默认时间为30s。</p>
</li>
<li><p>一个路由的失效定时器（Invalid timer）到期时它将被标记为无效路由（距离改为16）。每次更新该路由时其失效定时器都会被复位。默认值为180s。</p>
</li>
<li><p>一个路由的清除定时器（flush timer）到期时将从路由表中删除。默认值为240s。</p>
</li>
<li><p>抑制定时器（hold-down timer）是在路由的距离变为无穷大（包括收到毒化路由）时启动并在其到期之前不允许修改该路由的距离。默认值为180s。</p>
</li>
</ol>
<p>RIP协议对清除过时路径的处理是采用了两个定时器：超时(路由无效)计时器和垃圾收集(路由刷新)计时器。</p>
<p>路由器对表中的每个项目都设置两个计时器，每增加一个新路由条目，就相应的增加两个计时器。当新的路由条目被装入到路由表中时，超时计时器被初始化为<em>0</em>，并开始计数。每当收到包含该路由条目的RIP消息，该条目的超时计时器就被重新设置为0。</p>
<p>如果在180秒内没有接收到包含该路由条目的RIP消息，该路由的度量就被设置为16，而启动该路由的垃圾收集计时器。如果在接下来的60秒，仍没有收到该路由的RIP消息，该路由就从路由表中删除。如果在垃圾收集计时器到240秒之前，收到了包含路由的消息，路由条目被装入到路由表中，计时器被清0并重新启动超时计时器。</p>
<p><img src="https://img-blog.csdn.net/20180624204400836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L04xbmVEaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<h2 id="RIP协议的特点："><a href="#RIP协议的特点：" class="headerlink" title="RIP协议的特点："></a>RIP协议的特点：</h2><ul>
<li>RIP协议简单、容易实现</li>
<li>网络的直径不能超过16跳</li>
<li>不允许把一个大网络分成多个区</li>
<li>开销缺乏灵活性</li>
<li>存在慢收敛问题和计数到无穷问题</li>
<li>每30s发送完整路由表会消耗大量的带宽</li>
<li>实际运行的RIP协议具有以下特征：<ol>
<li>可以保存多达六个等距离的路由在路由表中，默认为4个</li>
<li>直连网的开销为0</li>
<li>发送的路由表会把所有距离加1</li>
</ol>
</li>
</ul>
<h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>OSPF协议（Open Shortest Path First），采用链路状态路由算法（利用最短路径算法，以自己为根，求出源节点到所有其他节点的最短路径），它可能使在大型企业中使用最广泛的内部网关协议（IGP）。</p>
<h2 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h2><p>为了适应大型的网络，OSPF在AS内划分多个区域，每个OSPF路由器只维护所在区域的完整链路状态信息，然后将一个区域的LSA简化和汇总后由边界路由（ABR）转发给另一个区域。</p>
<h2 id="路由器（DR和BDR）"><a href="#路由器（DR和BDR）" class="headerlink" title="路由器（DR和BDR）"></a>路由器（DR和BDR）</h2><ul>
<li><p>Router ID：OSPF区域内唯一标识路由器的IP地址</p>
</li>
<li><p>Router ID选取规则：</p>
<p>（自动选取）选取路由器loopback接口上数值最高的ip地址。如果没有loopback接口，在物理端口中选取ip地址最高的。</p>
<p>（手动选取）使用router-id命令指定Router ID</p>
</li>
<li><p>DR和BDR</p>
<p>当多台OSPF路由器连到同一个多路访问网段时，如果每两台路由器之间都相互交换LSA，那么该网段将充满着众多LSA条目，为了能够尽量减少LSA的传播数量，这时候需要一个路由器和所有的路由器互换LSA，减少LSA的数量，那么这个路由器被称为DR；在选DR的时候，也会选出一个作为备份，称为BDR；最后其他路由器（DRothers）只和DR和BDR形成邻接关系。</p>
</li>
<li><p>DR和BDR的选举方法<br><strong>自动选举DR和BDR</strong><br>网段上Router ID最大的路由器将被选举为DR，第二大的将被选举为BDR<br><strong>手工选择DR和BDR</strong><br>优先级范围是0～255，数值越大，优先级越高，默认为1<br>如果优先级相同，则需要比较Router lD<br>如果路由器的优先级被设置为0，它将不参与DR和DBR的选举<br>现实中，很少能有路由器同时开机，所以先上线的是DR，第二上线的是BDR。<br><strong>注：当DR和BDR存在时，除非他俩down了，不然没法强制更换。</strong></p>
</li>
<li><p>在OSPF中使用224.0.0.5和224.0.0.6作为组播地址，选举时，大家都是用组播地址224.0.0.5发送Hello包（这个时候路由器都认为自己是DR），当DR和BDR选出来后，DR和BDR使用224.0.0.5发送，其他路由器使用224.0.0.6发送。</p>
</li>
</ul>
<h2 id="OSPF的度量值：COST"><a href="#OSPF的度量值：COST" class="headerlink" title="OSPF的度量值：COST"></a>OSPF的度量值：COST</h2><p>规则：数值越小越优先。</p>
<h2 id="OSPF数据包"><a href="#OSPF数据包" class="headerlink" title="OSPF数据包"></a>OSPF数据包</h2><p>OSPF数据包承载在lP数据包内，使用协议号89</p>
<table>
<thead>
<tr>
<th>OSPF的包类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Hello包</td>
<td>用于发现和维持邻居关系，选举DR和BDR</td>
</tr>
<tr>
<td>数据库描述包(DBD)</td>
<td>用于向邻居发送摘要信息以同步链路状态数据库</td>
</tr>
<tr>
<td>链路状态请求包(LSR)</td>
<td>在路由器收到包含新信息的DBD后发送，用于请求更详细的信息</td>
</tr>
<tr>
<td>链路状态更新包(LSU)</td>
<td>收到LSR后发送链路状态通告(LSA)，一个LSU数据包可能包含几个LSA</td>
</tr>
<tr>
<td>链路状态确认包(LSAck)</td>
<td>确认已经收到DBD&#x2F; LSU，每个LSA需要被分别确认</td>
</tr>
</tbody></table>
<h2 id="OSPF的7个状态"><a href="#OSPF的7个状态" class="headerlink" title="OSPF的7个状态"></a>OSPF的7个状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Down状态</td>
<td>初始化，没有来自邻居的Hello包</td>
</tr>
<tr>
<td>Init状态</td>
<td>收到第一个Hello包，但没发出去，建立了自己的邻居表</td>
</tr>
<tr>
<td>2-Way状态</td>
<td>双向建立会话，邻居表都建立完成</td>
</tr>
<tr>
<td>Exstart状态</td>
<td>建立主从关系</td>
</tr>
<tr>
<td>Exchange状态</td>
<td>交换摘要信息，到确认信息收到</td>
</tr>
<tr>
<td>Loading状态</td>
<td>加载详细信息</td>
</tr>
<tr>
<td>Full状态</td>
<td>完全连接，计算最短路径，并载入路由表</td>
</tr>
</tbody></table>
<h2 id="OSPF的4个网络类型"><a href="#OSPF的4个网络类型" class="headerlink" title="OSPF的4个网络类型"></a>OSPF的4个网络类型</h2><table>
<thead>
<tr>
<th>网络类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>点到点网络(Point-to-Point)</td>
<td>自动发现邻居，不需DR&#x2F;BDR、组播224.0.0.5</td>
</tr>
<tr>
<td>广播多路访问网络(Broadcast MultiAccess，BMA)</td>
<td>自动发现邻居、选DR&#x2F;BDR、组播224.0.0.5、224.0.0.6</td>
</tr>
<tr>
<td>非广播多路访问网络(None Broadcast MultiAccess，NBMA)</td>
<td>手工指定邻居、选DR&#x2F;BDR、单播（AMT使用）</td>
</tr>
<tr>
<td>点到多点网络(Point-to-Multipoint)</td>
<td>自动发现邻居，不需DR&#x2F;BDR、组播224.0.0.5</td>
</tr>
</tbody></table>
<h2 id="OSPF的特点"><a href="#OSPF的特点" class="headerlink" title="OSPF的特点"></a>OSPF的特点</h2><ul>
<li>可适应大规模网络</li>
<li>路由变化收敛速度快</li>
<li>无路由环</li>
<li>支持变长子网掩码VLSM</li>
<li>支持区域划分</li>
<li>支持以组播地址发送协议报<h2 id="OSPF与RIP的比较"><a href="#OSPF与RIP的比较" class="headerlink" title="OSPF与RIP的比较"></a>OSPF与RIP的比较</h2><table>
<thead>
<tr>
<th>OSPF</th>
<th>RIP V1</th>
<th>RIP V2</th>
</tr>
</thead>
<tbody><tr>
<td>链路状态路由协议</td>
<td>距离矢量路由协议</td>
<td>距离矢量路由协议</td>
</tr>
<tr>
<td>没有跳数的限制</td>
<td>RIP的15跳限制，超过15跳的路由被认为不可达</td>
<td>RIP的15跳限制，超过15跳的路由被认为不可达</td>
</tr>
<tr>
<td>支持可变长子网掩码(VLSM)</td>
<td>不支持可变长子网掩码(VLSM)</td>
<td>支持可变长子网掩码(VLSM)</td>
</tr>
<tr>
<td>收敛速度快</td>
<td>收敛速度慢</td>
<td>收敛速度慢</td>
</tr>
<tr>
<td>使用组播发送链路状态更新</td>
<td>周期性广播更新整个路由表</td>
<td>周期性组播更新整个路由表</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>直通线和交叉线</title>
    <url>/2022/05/21/%E7%9B%B4%E9%80%9A%E7%BA%BF%E5%92%8C%E4%BA%A4%E5%8F%89%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="什么是交叉-x2F-直通线？"><a href="#什么是交叉-x2F-直通线？" class="headerlink" title="什么是交叉&#x2F;直通线？"></a>什么是交叉&#x2F;直通线？</h2><p>交叉线是两端使用不同的线序标准，一段使用568A线序，另一端为568B线序。主要用于同类网络设备的连接，如交换机与交换机、电脑与电脑等。</p>
<p>直通线是网线两端使用相同的线序标准，两端均使用568A或568B的线序。用于不同类的网络设备连接，如电脑与交换机、交换机与路由器等。</p>
<h2 id="为什么要用交叉线？"><a href="#为什么要用交叉线？" class="headerlink" title="为什么要用交叉线？"></a>为什么要用交叉线？</h2><p>在双绞线中，一对是发送信号，一对是接收信号，交叉线就是将收发对调，这样a设备发送端连接b设备接收端。这就是网线必须交叉的原因。</p>
<p>但是连交换机不用交叉线，因为交换机或者集线器的端口本来就是反的（带X的端口，cross-over），这时候就要用直通线连接。</p>
<h2 id="现在的网络设备"><a href="#现在的网络设备" class="headerlink" title="现在的网络设备"></a>现在的网络设备</h2><p>现在网络设备的网卡接口都有自适应功能，两端设备会自动协商，这样一般使用直通线就可以搞定。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机和路由器的区别</title>
    <url>/2022/05/21/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>工作层次不同。</p>
<p>交换机工作在数据链路层（第二层），路由器工作在网络层（第三层）。</p>
</li>
<li><p>转发依据不同</p>
<p>交换机根据MAC地址，路由器根据IP地址。</p>
</li>
<li><p>主要功能不同</p>
<p>交换机主要用于组建局域网，路由器是将交换机组好的局域网连接起来。</p>
<p>交换机能做的，路由器都能做。</p>
<p>交换机不能分割广播域，路由器可以。路由器还可以提供防火墙功能。</p>
</li>
</ol>
<p>路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Tricks</title>
    <url>/2022/05/18/C++%20Tricks/</url>
    <content><![CDATA[<h2 id="1-用-赋值。"><a href="#1-用-赋值。" class="headerlink" title="1.用{}赋值。"></a>1.用{}赋值。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">p = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">v = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">deque&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; d;</span><br><span class="line">d = &#123;&#123;&#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;, &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: d) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j: i)</span><br><span class="line">        cout &lt;&lt; j.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>&#125;; <span class="comment">//2 4 6 7</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">l = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;<span class="comment">//5 6 9 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-可以使用define定义宏指令（macros）"><a href="#2-可以使用define定义宏指令（macros）" class="headerlink" title="2.可以使用define定义宏指令（macros）"></a>2.可以使用define定义宏指令（macros）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> what_is(x) cerr &lt;&lt; #x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> a_variable = <span class="number">376</span>;</span><br><span class="line"><span class="built_in">what_is</span>(a_variable);</span><br><span class="line"><span class="comment">// prints &quot;a_variable is 376&quot;</span></span><br><span class="line"><span class="built_in">what_is</span>(a_variable * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// prints &quot;a_variable * 2 + 1 is 753&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-简化includes"><a href="#3-简化includes" class="headerlink" title="3.简化includes"></a>3.简化includes</h2><p>仅仅使用<code>#include &lt;bits/stdc++.h&gt;</code>，这个库包括了<code>algorithm</code>，<code>iostream</code>，<code>vector</code>等等，一般来说不用再调用其他库了。</p>
<h2 id="4-Hidden-function"><a href="#4-Hidden-function" class="headerlink" title="4.Hidden function"></a>4.Hidden function</h2><p>略</p>
<h2 id="5-变长参数"><a href="#5-变长参数" class="headerlink" title="5.变长参数"></a>5.变长参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, Args... args)</span> </span>&#123; <span class="keyword">return</span> a + <span class="built_in">sum</span>(args...); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>) + <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">/* prints &quot;23&quot; */</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><ul>
<li><p>auto关键字（也可以用auto&amp;）</p>
</li>
<li><p>tie和emplace_back</p>
</li>
<li><p>move</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; w = <span class="built_in">move</span>(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: v)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nw: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: w)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//v: </span></span><br><span class="line"><span class="comment">//w: 1 2 3 4 </span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计（OO Design）几大原则</title>
    <url>/2022/05/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88OO-Design%EF%BC%89%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>本文分享面向对象设计的六个设计原则：</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody><tr>
<td>SRP</td>
<td>Single Responsibility Principle</td>
<td>单一职责原则</td>
</tr>
<tr>
<td>OCP</td>
<td>Open Close Principle</td>
<td>开闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>Liskov Substitution Principle</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>LoD</td>
<td>Law of Demeter （ Least Knowledge Principle）</td>
<td>迪米特法则（最少知道原则）</td>
</tr>
<tr>
<td>ISP</td>
<td>Interface Segregation Principle</td>
<td>接口分离原则</td>
</tr>
<tr>
<td>DIP</td>
<td>Dependency Inversion Principle</td>
<td>依赖倒置原则</td>
</tr>
</tbody></table>
<p><a href="https://juejin.cn/post/6844903673672237063">https://juejin.cn/post/6844903673672237063</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>OOD</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类</title>
    <url>/2022/05/17/C++%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="C-类（Class）"><a href="#C-类（Class）" class="headerlink" title="C++类（Class）"></a>C++类（Class）</h1><h2 id="类声明与类定义"><a href="#类声明与类定义" class="headerlink" title="类声明与类定义"></a>类声明与类定义</h2><h3 id="类声明（declare）"><a href="#类声明（declare）" class="headerlink" title="类声明（declare）"></a>类声明（declare）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;</span><br></pre></td></tr></table></figure>

<p>在声明之后，定义之前，只知道Screen是一个类名，但不知道包含那些成员。只能以有限方式使用它，不能定义该类型的对象，只能用于定义指向该类型的指针或引用，声明（不是定义）使用该类型作为形参类型或者返回类型的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(Screen&amp; a)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">(Screen* a)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类定义（define）"><a href="#类定义（define）" class="headerlink" title="类定义（define）"></a>类定义（define）</h3><p>在创建类的对象之前，必须完整定义该类，而不只是声明类。所以，类不能具有自身类型的数据成员，但可以包含指向本类的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Screen window;</span><br><span class="line">	LinkScreen* next;</span><br><span class="line">	LinkScreen* prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意，分号不能丢，因为在类定义之后可以接一个对象定义列表，可类比内置类型，定义必须以分号结束。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;<span class="comment">/**...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkScreen</span>&#123;<span class="comment">/*...*/</span>&#125;scr1,scr2;</span><br></pre></td></tr></table></figure>

<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>复制构造函数是一种特殊构造函数，只有一个形参，该形参（常用const&amp;修饰）是对该类类型的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">	<span class="built_in">People</span>();<span class="comment">//默认构造函数</span></span><br><span class="line">	<span class="built_in">People</span>(<span class="type">const</span> People&amp;);<span class="comment">//复制构造函数</span></span><br><span class="line">	~<span class="built_in">People</span>();<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">People a1;</span><br><span class="line">People a2 = a1;</span><br></pre></td></tr></table></figure>

<p>当将该类型的对象传递给函数或者函数返回该类型的对象时，将隐式使用复制构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">People <span class="title">Func</span><span class="params">(People b)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制控制"><a href="#复制控制" class="headerlink" title="复制控制"></a>复制控制</h3><p>复制构造函数、赋值操作符和析构函数总称为复制控制。编译器自动实现这些操作，但类也可以定义自己的版本。</p>
<h3 id="两种初始化形式"><a href="#两种初始化形式" class="headerlink" title="两种初始化形式"></a>两种初始化形式</h3><p>直接初始化和复制初始化。直接初始化将初始化放在圆括号中，复制初始化使用&#x3D;号。</p>
<p>对于内置类型，例如int，double等，直接初始化和复制初始化没有区别。</p>
<p>对于类类型：直接初始化直接调用与实参匹配的构造函数；复制初始化先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象。直接初始化比复制初始化更快。</p>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><h3 id="重载赋值操作符"><a href="#重载赋值操作符" class="headerlink" title="重载赋值操作符"></a>重载赋值操作符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_item&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_item &amp;);</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元机制允许一个类将其非公有成员的访问权授予指定的函数或类。友元可以出现在类定义的内部的任何地方。友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Wife</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Consume</span><span class="params">(Husband&amp; h)</span></span>&#123;</span><br><span class="line">	h.money -=  <span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Husband h;</span><br><span class="line">Wife w;</span><br><span class="line">w.<span class="built_in">Consume</span>(h);</span><br></pre></td></tr></table></figure>

<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>;<span class="comment">//声明Husband</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Consume</span><span class="params">(Husband&amp; h)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Wife::Consume</span><span class="params">(Husband&amp; h)</span></span>;<span class="comment">//声明Consume函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Wife::Consume</span><span class="params">(Husband&amp; h)</span></span>&#123;</span><br><span class="line">h.money -= <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意类和函数的声明和定义的顺序：</p>
<p>(1)声明类Husband </p>
<p>(2)定义类Wife，声明Consume函数</p>
<p>(3)定义类Husband</p>
<p>(4)定义Consume函数。</p>
<h2 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h2><p>static数据成员是与类关联的对象，并不与该类的对象相关联。static成员遵循正常的共有&#x2F;私有访问规则。</p>
<h3 id="使用static成员而不是全局对象的三个优点："><a href="#使用static成员而不是全局对象的三个优点：" class="headerlink" title="使用static成员而不是全局对象的三个优点："></a>使用static成员而不是全局对象的三个优点：</h3><ul>
<li>static成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。</li>
<li>可以实施封装。static成员可以是私有成员，而全局对象不可以。</li>
<li>通过阅读程序容易看出static 成员是与特定类关联的，这种可见性清晰地显示程序员地意图。</li>
</ul>
<h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><p>在类的内部声明函数时需要添加static关键字，但是在类外部定义函数时就不需要了。因为static成员是类的组成部分但不是任何对象的组成部分，所以有以下几个特点：</p>
<ul>
<li>static函数没有this指针</li>
<li>static成员函数不能被声明为const（将成员函数声明为const就是承诺不会修改该函数所属的对象）</li>
<li>static成员函数也不能被声明为虚函数</li>
</ul>
<h3 id="static数据成员"><a href="#static数据成员" class="headerlink" title="static数据成员"></a>static数据成员</h3><p>应该在定义时初始化。</p>
<p>static成员变量的特点：</p>
<ul>
<li>属于类本身，不属于对象</li>
<li>程序运行过程中只有一个副本</li>
<li>不能在生成对象时初始化，即不能再构造函数中初始化</li>
</ul>
<h4 id="static变量初始化"><a href="#static变量初始化" class="headerlink" title="static变量初始化"></a>static变量初始化</h4><p>类体外进行，变量前不加static限定符；不加访问控制符；使用作用域运算符表明它所属类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> iCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> iCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::iCount = <span class="number">10</span>; <span class="comment">//在main函数外面初始化！</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.static数据成员的类型可以是该成员所属的类的类型。非static成员只能是自身类对象的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> Screen scr1;<span class="comment">//OK</span></span><br><span class="line">	Screen *scr2;<span class="comment">//OK</span></span><br><span class="line">	Screen scr3;<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.非static数据成员不能用作默认实参，static数据成员可靠用作默认实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">          <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">         <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//static const整形变量可以在类内部初始化。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>嵌套类就是在一个类中定义另一个类。这个被嵌套的类的作用域就只在它的上一级类中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c2</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c1::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> c1::c2::<span class="built_in">foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c1</span> f;</span><br><span class="line">    f.<span class="built_in">foo</span>();</span><br><span class="line">    f.b.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; f.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; f.b.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，被嵌套的类也可以是匿名的。匿名类的成员函数只能在类的声明中同时定义，因为这个类没有名称，没法再外部指代它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">c3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">3</span>;&#125;</span><br><span class="line">    <span class="keyword">class</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">4</span>;&#125;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c3</span> ff;</span><br><span class="line">    ff.<span class="built_in">foo</span>();</span><br><span class="line">    ff.b.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; ff.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ff.b.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>局部类就是定义在一个函数内部的类。这个类只能在这个函数内部使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c4</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;a = <span class="number">4</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">c4</span> ff;<span class="comment">//就是c4 ff</span></span><br><span class="line">    ff.<span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; ff.a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，嵌套类和局部类的所有成员变量都会被声明为共有的。因为这两种类只能在很小的范围内使用，没有必要通过定义接口来隐藏内部的信息。所以，可以把class改换成struct，这样就可以不写public了。</p>
<p>但是我们可以通过一些变通的方法来模拟出一个局部函数来。具体来说就是通过重载一个类的operator () 方法来模拟一个函数调用，下面给个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;HELLO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; foo;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CSMA/CA与CSMA/CD</title>
    <url>/2022/05/16/CSMA-CA%E4%B8%8ECSMA-CD/</url>
    <content><![CDATA[<p>1.CSMA&#x2F;CD媒体访问控制协议</p>
<p>　　由于以太网（Ethernet）成为现存局域网络结构的绝大多形式，CSMA&#x2F;CD（Carrier Sense Multiple ACcess&#x2F;Collision Detection）载波监测多址接人协议也成为局域网采用最多的MAC协议。CSMA&#x2F;CD适宜于总线型局域网拓扑结构的随机竞争型媒体访问控制。总线型网络允许同一时刻只有一个节点（Node）发送数据，一旦两个或以上节点同时发送数据，则会发生数据碰撞，数据不能正常发送和接收。CSMA&#x2F;CD协议就是尽可能保证网络上同时只有一个节点发送数据，减小数据“碰撞”概率。</p>
<p>　　CSMA&#x2F;CD工作过程：</p>
<p>　　当MAC收到LLG发来的数据以后，首先监测网络电缆上是否具有数据，即载波传送。<del>如果网络空闲，即没有载波传送，则将数据装帧，经物理层发送出去。如果网络繁忙，则监测网络直到网络空闲，再将数据装帧发送。</del></p>
<p>发送数据前 先侦听信道是否空闲 ,若空闲 则立即发送数据.在发送数据时,边发送边继续侦听.若侦听到冲突,则立即停止发送数据.等待一段随机时间,再重新尝试.</p>
<p>　 先听后发， 边发边听，冲突停发，随即延迟后重发</p>
<p>　　2.CSMA&#x2F;CA协议</p>
<p>　　CSMA作为随机竞争类MAC协议，具算法简单而且性能丰富，所以在实际局域网的使用中得到了广泛的应用。但是在无线局域网中，由于无线传输媒体固有的特性及移动性的影响，无线局域网的MAC在差错控制、解决隐藏终端等方面存在应有别于有线局域网。因此WLAN与有线局域网所采用的CSMA备一定的差异。WLAN采用CSMA&#x2F;CA（CSMA&#x2F;Collision　Avoidance）协议，其与CSMA&#x2F;CD最大的不同点在于其采取避免冲突工作方式。</p>
<p>　　与CSMA&#x2F;CD不同，WLAN媒体访问控制（MAC）层采用的CSMA&#x2F;CA（CSMA&#x2F;Collision Avoidance）协议，由于在RF传输网络中冲突检测比较困难，所以该协议用避免冲突检测代替802.3协议使用的冲突检测，采用冲突避免机制尽量减小冲突碰撞发生的概率，以提高网络吞吐性能与迟延性能。协议使用信道空闲评估（CCA）算法来决定信道是否空闲，通过测试天线能量和决定接收信号强度RSSI来完成，并且使用RTS、CTS和ACK帧减少冲突。数据加密与普通局域网的等同加密（WEP）算法一样，使用64位密钥和RC4加密算法。</p>
<p>　　CSMA&#x2F;CA工作过程</p>
<p>　　当发射端希望发送数据时，首先检测介质是否空闲，若是介质为空闲时，送出RTS（Request To Send请求发送），RTS信号包括发射端的地址、接收端的地址、下一笔数据将持续发送的时间等信息，接收端收到RTS信号后，将响应短信号CTS（Clear To Send），CTS信号上也RTS内记录的持续发送的时间，当发射端收到CTS包后，随即开始发送数据包。接收端收到数据包后，将以包内的CRC（CyClic Redundancy Check，循环冗余校验）的数值来检验包数据是否正确，若是检验结果正确时，接收端将响应ACK包，告知发射端数据己经被成功地接收。当发射端没有收到接收端的ACK包时，将认为包在传输过程中丢失，而一直重新发送包。</p>
<p>　　3.CSMA&#x2F;CA与CSMA&#x2F;CD的区别</p>
<p>　　（1）载波检测方式：因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式。</p>
<p>　　（2）信道利用率比较CSMA&#x2F;CA协议信道利用率低于CSMA&#x2F;CD协议信道利用率。但是由于无线传输的特性，在无线局域网不能采用有线局域网的CSMA&#x2F;CD协议。信道利用率受传输距离和空旷程度的影响，当距离远或者有障碍物影响时会存在隐藏终端问题，降低信道利用率。</p>
<p>　　具体最高的信道利用率与传输速率有关。在IEEE802.11b无线局域网中，在1Mb&#x2F;s速率时最高信道利用率可到90%，而在11Mb&#x2F;s时最高信道利用率只有65%左右。</p>
<p>区别：</p>
<p>从名字上就可以看出， 不同就是一个是ca（collision avoidance）, 而另一个是cd（collision detection）。802.3以太网用的是cd，就是冲突检测，发生冲突并且检测到冲突后重传。 802.11无线局域网用的是ca， 就是冲突避免， 也是就是在传输以前先检测信道，然后通过RTS&#x2F;CTS来预约信道，达到冲突避免的目的。<br>csma, 就是carrier sense，也就是说两者都是在发送前检测信道是否繁忙，不同当然就是以上所说。</p>
<p><a href="https://blog.csdn.net/Esther_Heesch/article/details/51173722">(45条消息) CSMA&#x2F;CA与CSMA&#x2F;CD的区别_王胜飞的博客-CSDN博客_csmaca和csmacd的区别</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20731045">802.11协议精读3：CSMA&#x2F;CD与CSMA&#x2F;CA - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网ARP</title>
    <url>/2022/05/15/%E8%AE%A1%E7%BD%91ARP/</url>
    <content><![CDATA[<p>我们知道，在浏览器输入网址，DNS服务器会自动解析为IP地址。那么IP地址是如何转换为第二层MAC地址呢？在局域网中，这是用过ARP协议来完成的。</p>
<span id="more"></span>

<h2 id="什么是ARP协议"><a href="#什么是ARP协议" class="headerlink" title="什么是ARP协议"></a>什么是ARP协议</h2><p>ARP协议就是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网中，一个主机和另一个主机直接进行通信，必须知道目标主机的MAC地址，而它就是通过ARP协议获得的。所谓“地址解析”就是主机在发送帧前将目标地址转换成目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p>
<h2 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h2><p>每台安装有TCP&#x2F;IP协议的电脑里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的。在发送数据时，主机A会在自己的ARP缓存表中寻找是狗有目标IP地址，如果找到了，也就知道了目标MAC地址，直接把目标MAC地址写入帧中就可以发送。如果ARP缓存表中没有找到对应的MAC地址，主机A就会在网络上发送一个广播，目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出询问，目标IP的MAC地址是什么？网络上其他主机并不相应ARP询问，只有主机B接收到这和帧时，才向主机A做出回应其MAC地址。这样主机A就知道了B的MAC地址，就可以向主机B发送消息了。同时它还更新了自己的ARP缓存表，下次再向B发送消息时，直接从ARP缓存表里查找。ARP缓存中如果某一行在一段时间内没有使用，就会被删除。这样可以减少ARP缓存表的长度，加快查询速度。</p>
<p>ARP攻击就是伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量ARP通信量使网络拥塞，攻击者只要持续不断地发出伪造的ARP相应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p>
<p>ARP攻击主要是存在于局域网中，局域网中若有一个人感染ARP木马，则该感染木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p>
<p>RARP的工作原理：</p>
<ol>
<li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； </li>
<li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； </li>
<li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用； </li>
<li>如果不存在，RARP服务器对此不做任何的响应； </li>
<li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li>
</ol>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库ACID</title>
    <url>/2022/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/</url>
    <content><![CDATA[<p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）的正确可靠的，所必须具有的四个特性：原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。</p>
<span id="more"></span>

<p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成。如果发生错误就会Rollback，回到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。</p>
<p>隔离性：数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务的隔离分为不同级别，包括读未提交（Read Uncommitted)、读提交（Read committed）、可重复读（Repeatable read）、和串行化（Serializable）。</p>
<p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>大二</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ explicit</title>
    <url>/2022/05/14/C++explicit/</url>
    <content><![CDATA[<p>C++中有隐式转换（implicit conversion）和显示转换（explicit conversion）。如果要避免隐式转换，就要用到关键字explicit。</p>
<span id="more"></span>

<p>看一看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>(<span class="type">int</span> n) : <span class="built_in">data</span>(n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInteger n1 = <span class="number">5</span>;</span><br><span class="line">    <span class="function">MyInteger <span class="title">n2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，即使是用的等号赋值，也会隐式转换成MyInteger(int n)，调用构造函数，而不是重载的<code>operator=</code>运算符。但是如果在构造函数前面加上explicit关键字，告诉编译器只能显示转换，这样上面的代码就会报错。</p>
<p>还有一种错误，就是在传递参数时，会触发函数的隐式调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPoint</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">         &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">displayPoint</span>(<span class="number">1</span>);</span><br><span class="line">    Point p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>explicit关键字可能更多用于字符串？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">int</span> n) &#123; <span class="comment">// allocate n bytes to the MyString object</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyString(int n)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123; <span class="comment">// initializes object with char *p</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyString(const char *p)\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyString s1 = <span class="number">10</span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyString s3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s4</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对string的常用操作</title>
    <url>/2022/05/12/C-%E5%AF%B9string%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="数字与字符串互相转换"><a href="#数字与字符串互相转换" class="headerlink" title="数字与字符串互相转换"></a>数字与字符串互相转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="built_in">to_string</span>(num);</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(s);</span><br></pre></td></tr></table></figure>

<h2 id="字符串中的字符按大小排序"><a href="#字符串中的字符按大小排序" class="headerlink" title="字符串中的字符按大小排序"></a>字符串中的字符按大小排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s,<span class="built_in">end</span>(),[](<span class="type">char</span> a,<span class="type">char</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="字符串中两个位置的字符交换"><a href="#字符串中两个位置的字符交换" class="headerlink" title="字符串中两个位置的字符交换"></a>字符串中两个位置的字符交换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(s[i],s[j]);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++枚举类型</title>
    <url>/2022/05/11/C-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++智能指针</title>
    <url>/2022/05/11/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针不是一个指针，其实是一个对象，它是通过C++的RAII机制实现的。主要是利用C++中对象在释放的时候，会自动调用析构函数这一特性。</p>
<span id="more"></span>
<p>所以，当智能指针对象释放的时候，在智能指针对象的析构函数中来释放其管理的内存资源。这样，开发人员就不需要手动区释放已经分配的内存空间。<br>C++17标准之后，C++标准中还有三种智能指针：shared_ptr、unique_ptr、weak_ptr。<br>详细见知乎专栏。<br><a href="https://zhuanlan.zhihu.com/p/336293980">https://zhuanlan.zhihu.com/p/336293980</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++操作符重载</title>
    <url>/2022/05/11/C++%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>操作符重载是为了对自定义类进行运算，本质是一个函数，可以采用友元函数或者成员函数的方式实现。（成员函数默认传递this指针，可以少一个参数；而全局函数如果要访问私有变量，则需要转化为友元函数）</p>
<span id="more"></span>

<h2 id="操作符重载的格式"><a href="#操作符重载的格式" class="headerlink" title="操作符重载的格式"></a>操作符重载的格式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#全局函数</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; a1, <span class="type">const</span> A&amp; a2)</span><br><span class="line">#成员函数</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; obj)</span><br></pre></td></tr></table></figure>

<p>函数名为operator与运算符的组合，输入为对象，返回值可以为元素、对象或者引用。</p>
<h2 id="可以重载的运算符"><a href="#可以重载的运算符" class="headerlink" title="可以重载的运算符"></a>可以重载的运算符</h2><p><img src="https://img-blog.csdnimg.cn/20210304230908930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lKWVNfWkhY,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="实例：实现complex类的±运算符重载"><a href="#实例：实现complex类的±运算符重载" class="headerlink" title="实例：实现complex类的±运算符重载"></a>实例：实现complex类的±运算符重载</h2><p>注意：使用友元函数需要注意的是，二元运算则传递两个参数，同时添加friend关键字，使用成员函数只需要一个参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - obj.a, <span class="keyword">this</span>-&gt;b - obj.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + x2.a, x1.b + x2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	Complex x3 = x1 + x2;</span><br><span class="line">	x3.<span class="built_in">printC</span>();</span><br><span class="line"></span><br><span class="line">	Complex x4 = x2 - x1;</span><br><span class="line">	x4.<span class="built_in">printC</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例：基于3实现complex类的前置-以及后置"><a href="#实例：基于3实现complex类的前置-以及后置" class="headerlink" title="实例：基于3实现complex类的前置-以及后置++"></a>实例：基于3实现complex类的前置-以及后置++</h2><p>注意：</p>
<p>1）后置++需要在参数列表中增加占位符int，complex operator++（complex&amp;obj，int）</p>
<p>2）后置++先使用后++，如a++，在具体实现时就要先使用临时变量tmp暂存输入，而后++，最后返回临时变量。</p>
<p>3）传递的变量最好在引用&amp;前使用const，保持变量的内存空间不能改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2);</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>++(Complex&amp; obj, <span class="type">int</span>);</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; obj)<span class="comment">//-</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - obj.a, <span class="keyword">this</span>-&gt;b - obj.b)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现前置--</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a++;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">const</span> Complex&amp; x2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + x2.a, x1.b + x2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数实现后置++,后置需要增加占位符</span></span><br><span class="line">Complex <span class="keyword">operator</span>++(Complex&amp; obj, <span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Complex tmp = obj;<span class="comment">//其中如果有指针，那么需要注意浅拷贝</span></span><br><span class="line">	obj.a++;</span><br><span class="line">	obj.b++;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	Complex x3 = x1 + x2;</span><br><span class="line">	x3.<span class="built_in">printC</span>(); <span class="comment">//4,6</span></span><br><span class="line">	--x3;</span><br><span class="line">	Complex x4 = x2 - x1;</span><br><span class="line">	x4.<span class="built_in">printC</span>();<span class="comment">//2,2</span></span><br><span class="line">	Complex x5 = x4++;</span><br><span class="line">	x4.<span class="built_in">printC</span>();<span class="comment">//3,3</span></span><br><span class="line">	x5.<span class="built_in">printC</span>();<span class="comment">//2,2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例：实现complex左移-lt-lt-和右移-gt-gt-的重载"><a href="#实例：实现complex左移-lt-lt-和右移-gt-gt-的重载" class="headerlink" title="实例：实现complex左移&lt;&lt;和右移&gt;&gt;的重载"></a>实例：实现complex左移&lt;&lt;和右移&gt;&gt;的重载</h2><p>注意：</p>
<p>1）类似&lt;&lt;操作符重载，其为二元运算符，两个操作数类型不同，分别为ostream和complex</p>
<p>2）实现两个操作数类型不同的运算符重载要使用友元函数</p>
<ul>
<li>原因是，成员函数重载operator+，调用a+1时相当于调用a.operator(1)，只能保证一种参数顺序的运算，两个参数更换位置就失败，即1+a时就会报没有对应的操作符重载。</li>
<li>友元函数可以通过重载友元函数来实现，只调换参数位置即可实现。</li>
<li>要实现链式编程，返回引用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Complex&amp; obj);</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">int</span> i);</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">int</span> i, <span class="type">const</span> Complex&amp; x1);</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; obj);</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="type">int</span> i) <span class="comment">//成员函数重载-</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Complex <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a - i, <span class="keyword">this</span>-&gt;b - i)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; x1, <span class="type">int</span> i) <span class="comment">//友元函数重载+  （1）</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + i, x1.b + i)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">int</span> i, <span class="type">const</span> Complex&amp; x1)<span class="comment">//友元函数重载+   （2）</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(x1.a + i, x1.b + i)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数实现重载&lt;&lt;左移操作符，输出，且只能采用友元函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Complex&amp; obj)<span class="comment">//此处将ostream类型的out变量本身返回，以便后续的连续操作</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; obj.a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; obj.b &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#原来自己是这么实现的，但是不支持cin&gt;&gt;x1&gt;&gt;x2的链式编程的情况</span><br><span class="line"><span class="comment">// void operator&gt;&gt;(istream&amp; in, Complex&amp; obj)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	in &gt;&gt; obj.a;</span></span><br><span class="line"><span class="comment">// 	in &gt;&gt; obj.b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	in &gt;&gt; obj.a;</span><br><span class="line">	in &gt;&gt; obj.b;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">x1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">x2</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; x1 + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="number">1</span> + x1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; x1 - <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; x1 &gt;&gt; x2;</span><br><span class="line">	cout &lt;&lt; x1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载等号-x3D-操作符"><a href="#重载等号-x3D-操作符" class="headerlink" title="重载等号&#x3D;操作符"></a>重载等号&#x3D;操作符</h2><p>有指针的类定义的对象，在等号&#x3D;赋值时，采用C++的赋值，进行的时浅拷贝，导致两个对象的指针指向同一个内存空间，释放的时候出现问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> <span class="type">char</span>* p)<span class="comment">//“asdb”</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_len = <span class="built_in">strlen</span>(p);</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Name</span>(<span class="type">const</span> Name&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_len = obj.m_len;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, obj.m_p);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Name</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_len != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_p;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_p = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Name&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Name&amp; obj)<span class="comment">//重载等号操作符，实现连等，返回一个引用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_p!=<span class="literal">NULL</span>) <span class="comment">//先释放旧的指针</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_p;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_p = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_len = obj.m_len;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="keyword">this</span>-&gt;m_len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_p, obj.m_p);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_p;</span><br><span class="line">	<span class="type">int</span> m_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Name <span class="title">obj</span><span class="params">(<span class="string">&quot;asdf&quot;</span>)</span></span>;<span class="comment">//双引号代表字符串，单引号代表字符，并且其可转化为int的ASCII码</span></span><br><span class="line">	<span class="function">Name <span class="title">obj2</span><span class="params">(<span class="string">&quot;sdgf&quot;</span>)</span></span>;</span><br><span class="line">	Name obj3 = obj2;</span><br><span class="line">	obj2 = obj;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组类案例"><a href="#数组类案例" class="headerlink" title="数组类案例"></a>数组类案例</h2><p>【C++】数组类案例，实现<a href="https://blog.csdn.net/YJYS_ZHX/article/details/114462206"> ] 、&#x3D;&#x3D;、 !&#x3D;的重载_剑宇2022的博客-CSDN博客</a></p>
<h2 id="字符串类案例"><a href="#字符串类案例" class="headerlink" title="字符串类案例"></a>字符串类案例</h2><p>略</p>
<h2 id="重载（）操作符"><a href="#重载（）操作符" class="headerlink" title="重载（）操作符"></a>重载（）操作符</h2><p>重载（）操作符，在定义对象后，可以使用f（），类似于f.operator()操作。可以给对象传参数，输出结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F f;</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不要重载-amp-amp-以及"><a href="#不要重载-amp-amp-以及" class="headerlink" title="不要重载&amp;&amp;以及||"></a>不要重载&amp;&amp;以及||</h2><p>作用于基础类型的&amp;&amp;和||有短路规则，但是经过重载后，就没有短路规则了，原因是重载是一种函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;i = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Test&amp;  <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;i = <span class="keyword">this</span>-&gt;i + obj.i;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&amp;&amp;(<span class="type">const</span> Test&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i &amp;&amp; obj.i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	t1 &amp;&amp; (t1 + t2);<span class="comment">//重载&amp;&amp;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello,world...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处重载&amp;&amp;，但是仍然先计算+加号重载的操作符，后计算&amp;&amp;重载，而不是先判断t1。</p>
]]></content>
  </entry>
  <entry>
    <title>C++unordered_map</title>
    <url>/2022/05/10/C++unordered-map/</url>
    <content><![CDATA[<h2 id="unordered-map-初始化"><a href="#unordered-map-初始化" class="headerlink" title="unordered_map 初始化"></a>unordered_map 初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">std::unordered_map&lt;std::string,<span class="type">int</span>&gt; umap = &#123;</span><br><span class="line">	&#123;<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Ann&quot;</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map-插入元素"><a href="#unordered-map-插入元素" class="headerlink" title="unordered_map 插入元素"></a>unordered_map 插入元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">umap[<span class="string">&quot;John&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">umap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string,<span class="type">int</span>&gt;(<span class="string">&quot;John&quot;</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map-根据key值查找元素"><a href="#unordered-map-根据key值查找元素" class="headerlink" title="unordered_map 根据key值查找元素"></a>unordered_map 根据key值查找元素</h2><p>直接用中括号获取，如果map中没有，则不会输出任何结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; umap[<span class="string">&quot;John&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map-移除元素"><a href="#unordered-map-移除元素" class="headerlink" title="unordered_map 移除元素"></a>unordered_map 移除元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">umap.<span class="built_in">erase</span>(umap.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>

<h2 id="遍历unordered-map"><a href="#遍历unordered-map" class="headerlink" title="遍历unordered_map"></a>遍历unordered_map</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : umap) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用迭代器</span></span><br><span class="line"><span class="keyword">for</span> (std::unordered_map&lt;std::string, <span class="type">int</span>&gt;::iterator it = umap.<span class="built_in">begin</span>(); it != umap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// for (auto it = umap.begin(); it != umap.end(); it++) &#123;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; (*it).second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="清空，判断是否为空"><a href="#清空，判断是否为空" class="headerlink" title="清空，判断是否为空"></a>清空，判断是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">umap.<span class="built_in">clear</span>();</span><br><span class="line">umap.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h2 id="根据key查找元素"><a href="#根据key查找元素" class="headerlink" title="根据key查找元素"></a>根据key查找元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (um.<span class="built_in">find</span>(<span class="number">23</span>) == um.<span class="built_in">end</span>()) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element Not Present\n&quot;</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element Present\n&quot;</span>; </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对字符串排序</title>
    <url>/2022/05/02/Java%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>方法1：冒泡排序 ：<br>思路：先获取字符串数组里的每个字符串，然后使用toCharArray()方法得到这个字符串的char[] 再对char数组里的元素进行对比，冒泡排序前面大的与后面交换顺序，再把得到的char数组重新转换为String，存入到一个新的String数组中，然后在整体对新数组中各个字符串使用冒泡排序从而得到结果)<br>方法2：使用 Arrays.sort(s)；方法进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> class 字符排序 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] str  = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;fcc&quot;</span>,<span class="string">&quot;egfd&quot;</span>,<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;rtgh&quot;</span>,<span class="string">&quot;deghk&quot;</span>,<span class="string">&quot;fcc&quot;</span>&#125;;</span><br><span class="line"><span class="comment">/*方法1：冒泡排序   ：</span></span><br><span class="line"><span class="comment">		思路：先获取字符串数组里的每个字符串，然后使用toCharArray()方法得到这个字符串的char[] 再对char数</span></span><br><span class="line"><span class="comment">			组里的元素进行对比，冒泡排序前面大的与后面交换顺序，再把得到的char数组重新转换为String，存入到一个新的String</span></span><br><span class="line"><span class="comment">			数组中，然后在整体对新数组中各个字符串使用冒泡排序从而得到结果)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	printArr(stringRank(test(str)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法2：使用 Arrays.sort(s)；方法进行排序</span></span><br><span class="line">	String[] s = sortChar(str);</span><br><span class="line">	Arrays.sort(s);</span><br><span class="line">	printArr(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一个每个字符串里元素已经进行过排序的新字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] test(String[] str)&#123;</span><br><span class="line">	String st[] =  st = <span class="keyword">new</span> <span class="title class_">String</span>[str.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">		<span class="type">char</span>[] c =  str[i].toCharArray();</span><br><span class="line">		charRank(c);</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">		st[i]  = s; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对字符串里元素进行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">charRank</span><span class="params">(<span class="type">char</span>[] c)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c.length; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j2</span> <span class="operator">=</span> <span class="number">0</span>; j2 &lt; c.length-j-<span class="number">1</span>; j2++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(c[j2]&gt;c[j2+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="type">char</span> <span class="variable">len</span> <span class="operator">=</span> c[j2];</span><br><span class="line">				c[j2] = c[j2+<span class="number">1</span>];</span><br><span class="line">				c[j2+<span class="number">1</span>] = len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 对新字符串数组里的字符串进行排序(升序)字符串比较使用compareTo()方法，</span></span><br><span class="line"><span class="comment">String本身并不具备比较大小功能，它的String对象实现了Comparable接口，这个接口是具有比较大小功能的接口，里面定义了比较方法compareTo()方法，</span></span><br><span class="line"><span class="comment">所以如果我们定义了一个类，这个类产生的对象需要比较大小就需要去实现Comparable接口，重写compareTo()方法，这种</span></span><br><span class="line"><span class="comment">排序成为类的自然排序，compareTo()方法称为自然比较方法，因为String类已经实现了compareTo()方法，所以这里可以直接使用</span></span><br><span class="line"><span class="comment">该方法的比较对象与指定对象的顺序。</span></span><br><span class="line"><span class="comment">compareTo(T  o)    返回值：int  返回0(两者相等)，负数(对象小于参数)，正数(对象大于参数)     参数o为要比较的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] stringRank(String[] str) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j].compareTo(str[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str[j];</span><br><span class="line">				str[j] = str[j + <span class="number">1</span>];</span><br><span class="line">				str[j + <span class="number">1</span>] = s;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] sortChar(String[] str) &#123;</span><br><span class="line">	String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[str.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">		<span class="type">char</span>[] c = str[i].toCharArray();</span><br><span class="line">		Arrays.sort(c);</span><br><span class="line">		s[i] = String.valueOf(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(String[] str)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">		System.out.print(str[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数详解</title>
    <url>/2022/04/28/%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、多态与重载"><a href="#一、多态与重载" class="headerlink" title="一、多态与重载"></a>一、多态与重载</h2><h3 id="1、多态的概念"><a href="#1、多态的概念" class="headerlink" title="1、多态的概念"></a>1、多态的概念</h3><p>面向对象的语言有三大特性：封装、继承和多态。虚函数作为多态的实现方式，重要性毋庸置疑。</p>
<p>多态指给予不同的对象会引发不同的动作（一个接口，多种方法）。其实现更简单地来说，就是“在用父类指针调用函数时，实际调用的时指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定，而不是在编译器静态确定。</p>
<h3 id="2、重载–编译期多态的体现"><a href="#2、重载–编译期多态的体现" class="headerlink" title="2、重载–编译期多态的体现"></a>2、重载–编译期多态的体现</h3><p>重载，是指在一个类中的同名不同参的函数调用，这样的方法调用是在编译器确定的。</p>
<h3 id="3、虚函数–运行期多态的体现"><a href="#3、虚函数–运行期多态的体现" class="headerlink" title="3、虚函数–运行期多态的体现"></a>3、虚函数–运行期多态的体现</h3><p>运行期多态发生的三个条件：继承关系、虚函数覆盖、父类指针或引用指向子类对象。</p>
<h2 id="二、虚函数实例"><a href="#二、虚函数实例" class="headerlink" title="二、虚函数实例"></a>二、虚函数实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vir_func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;virtual function, this is class B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;normal function, this is class B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    base *Base = <span class="built_in">new</span>(base);</span><br><span class="line">    base *a = <span class="built_in">new</span>(A);</span><br><span class="line">    base *b = <span class="built_in">new</span>(B);</span><br><span class="line">    Base-&gt;<span class="built_in">func</span>();a-&gt;<span class="built_in">func</span>();b-&gt;<span class="built_in">func</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;#########################&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Base-&gt;<span class="built_in">vir_func</span>();a-&gt;<span class="built_in">vir_func</span>();b-&gt;<span class="built_in">vir_func</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;#########################&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ((A *)b)-&gt;<span class="built_in">vir_func</span>();((A *)b)-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">normal function, this is class base</span><br><span class="line">normal function, this is class base</span><br><span class="line">normal function, this is class base</span><br><span class="line">#########################</span><br><span class="line">virtual function, this is class base</span><br><span class="line">virtual function, this is class A</span><br><span class="line">virtual function, this is class B</span><br><span class="line">#########################</span><br><span class="line">virtual function, this is class B</span><br><span class="line">normal function, this is class A</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，当这三个指针调用func函数时，调用的都是基类base的函数。而调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后对b做强制类型转换，转换为A类型的指针，发现普通函数调用类A的函数，虚函数调用类B的函数。</p>
<p>以上，我们可以得出结论：<strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定</strong></p>
<p>虚函数的实现过程：通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。</p>
<h2 id="三、虚函数的实现（内存布局）"><a href="#三、虚函数的实现（内存布局）" class="headerlink" title="三、虚函数的实现（内存布局）"></a>三、虚函数的实现（内存布局）</h2><p>虚函数表中只存有一个虚函数的指针地址，不存放普通函数或是构造函数的指针地址。只要有虚函数，C++类都会存在这样的一张虚函数表。不管是普通函数亦或是纯虚函数，亦或是派生类中隐式声明的这些虚函数都会生成这张虚函数表。</p>
<p>虚函数表创建的时间：在一个类构造的时候，创建这张虚函数表，而这个虚函数表是供整个类所共有的。虚函数表存储在对象最开始的位置。虚函数表其实就是函数指针的地址。函数调用的时候，通过函数指针指向的函数来调用函数。</p>
<p>虚函数表存储在对象的最开始的位置，按照声明顺序存放在表中，父类的虚函数在子类的虚函数前面。如果有虚函数覆盖，覆盖的f()函数被放在虚表中原来父类虚函数的位置，没有被覆盖的函数依旧在原来的位置。</p>
<p>如果有多重继承，每个父类都有自己的虚表（有几个基类就有几个虚函数表），子类的成员函数被放到了第一个父类的表中（按声明顺序来判断）。如果有虚函数覆盖，那么所有父类中的f()位置都会被替换成子类的函数指针。</p>
<h2 id="四、虚函数的相关问题"><a href="#四、虚函数的相关问题" class="headerlink" title="四、虚函数的相关问题"></a>四、虚函数的相关问题</h2><h3 id="1、构造函数为什么不能定义为虚函数？"><a href="#1、构造函数为什么不能定义为虚函数？" class="headerlink" title="1、构造函数为什么不能定义为虚函数？"></a>1、构造函数为什么不能定义为虚函数？</h3><p><strong>构造函数不能是虚函数</strong></p>
<p>首先，我们已经知道虚函数的实现是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来说就是为对象内存中的值做初始化操作。那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在代码区。</p>
<h3 id="2、析构函数为什么要定义为虚函数？"><a href="#2、析构函数为什么要定义为虚函数？" class="headerlink" title="2、析构函数为什么要定义为虚函数？"></a>2、析构函数为什么要定义为虚函数？</h3><p><strong>析构函数可以是虚函数且推荐最好设置为虚函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;B()\n&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;~B()\n&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;D()\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;~D()\n&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pB = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> pB;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">B&lt;&gt;</span><br><span class="line">D&lt;&gt;</span><br><span class="line">~D&lt;&gt;</span><br><span class="line">~B&lt;&gt;</span><br></pre></td></tr></table></figure>

<p>C++中有这样的约束：执行子类构造函数之前一定会执行父类的构造函数；同理，执行子类的析构函数后，一定会执行父类的析构函数，这也是为什么建议析构函数写成虚函数的原因。</p>
<p>如果析构函数不是虚函数，那么delete(a)时，调用的将是基类base的析构函数。而继承时派生类通常会在基类的基础上定义自己的成员，此时我们当然是希望可以调用派生类的析构函数对新定义的成员也进行析构了。</p>
<h3 id="3、如何取验证虚函数表的存在？"><a href="#3、如何取验证虚函数表的存在？" class="headerlink" title="3、如何取验证虚函数表的存在？"></a>3、如何取验证虚函数表的存在？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 取类的一个实例</span></span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 把&amp;b转成int ，取得虚函数表的地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 再次取址就可以得到第一个虚函数的地址了</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;虚函数表 — 第一个函数地址：&quot;</span> &lt;&lt; (<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b) &lt;&lt; endl;</span><br><span class="line">pFun = (Fun)*((<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b));</span><br><span class="line"><span class="built_in">pFun</span>();</span><br></pre></td></tr></table></figure>

<h2 id="4、纯虚函数"><a href="#4、纯虚函数" class="headerlink" title="4、纯虚函数"></a>4、纯虚函数</h2><p>纯虚函数：不能实例化对象，可以做指针和引用，拥有纯虚函数的类是抽象类。</p>
<p>作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义。如果在基类中没有保留函数名字，则无法实现多态性。</p>
<p>声明格式：virtual  类型  函数名(参数列表）&#x3D; 0</p>
<p>（1）纯虚函数没有函数体；<br>（2）最后面的“&#x3D;0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”；<br>（3）这是一个声明语句，最后有分号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//声明为纯虚函数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/2022/04/25/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java函数式编程</title>
    <url>/2022/04/25/java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>javaJDBC编程</title>
    <url>/2022/04/25/javaJDBC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>javaXML于JSON</title>
    <url>/2022/04/25/javaXML%E4%BA%8EJSON/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java网络编程</title>
    <url>/2022/04/25/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>javaMaven基础</title>
    <url>/2022/04/25/javaMaven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2022/04/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><p>操作系统轮流让多个任务交替进行，在人开来，cpu就是在同时进行多个任务。即使是多核CPU，通常任务的数量仍远远多于cpu核数，所以任务也是交替进行的。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在计算机中，我们把一个任务称为一个进程（Process）。例如，浏览器是一个进程，视频播放器是另一个进程。</p>
<p>某些进程内部还需要同时执行多个子任务，例如，Word可以一边打字一边进行拼写检查。我们把子任务称为线程（Thread）。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<p>实现多任务的方法有三种：多进程模式（每个进程只有一个线程）、多线程模式、多进程+多线程模式。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快</li>
</ul>
<p>而多进程的优点在于：</p>
<ul>
<li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，用一个主线程序来执行main方法，在main方法内部，我们又可以启动多个线程。此外，还有GC等其他工作线程等。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>创建一个新线程非常容易，需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望新线程能执行指定的代码，有几种方法：</p>
<p>方法一：从<code>Thread</code>派生一个自定义类，然后Override<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者用Java8引入的lambda语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>调用<code>interrupu()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java加密于安全</title>
    <url>/2022/04/25/java%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h2><p>Ascii码，Unicode，UTF-8</p>
<p>URL编码：如果字符时字母、数字、<code>-</code>，<code>_</code>，<code>.</code>，<code>*</code>。则保持不变。如果URL包含中文等非Ascii字符，先转换为UTF-8编码，然后对每个<b>字节</b>以<code>%xx</code>表示。</p>
<p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p>
<p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p>
<p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>URL编码是对字符串进行编码，表示成<code>%xx</code>的形式，而Base64编码是ui二进制数据进行编码，表示成文本格式。</p>
<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code><del><code>Z</code>、<code>a</code></del><code>z</code>、<code>0</code>~&#96;9<code>、</code>+<code>、</code>&#x2F;<code>、</code>&#x3D;&#96;这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>
<p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; (<span class="type">byte</span>) <span class="number">0xe4</span>, (<span class="type">byte</span>) <span class="number">0xb8</span>, (<span class="type">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64encoded</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。但是缺点是传输效率会很低，因为它把原始数据的长度增加了1&#x2F;3.</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>常用的哈希算法有：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">输出长度（位）</th>
<th align="left">输出长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MD5</td>
<td align="left">128 bits</td>
<td align="left">16 bytes</td>
</tr>
<tr>
<td align="left">SHA-1</td>
<td align="left">160 bits</td>
<td align="left">20 bytes</td>
</tr>
<tr>
<td align="left">RipeMD-160</td>
<td align="left">160 bits</td>
<td align="left">20 bytes</td>
</tr>
<tr>
<td align="left">SHA-256</td>
<td align="left">256 bits</td>
<td align="left">32 bytes</td>
</tr>
<tr>
<td align="left">SHA-512</td>
<td align="left">512 bits</td>
<td align="left">64 bytes</td>
</tr>
</tbody></table>
<p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希算法的用途"><a href="#哈希算法的用途" class="headerlink" title="哈希算法的用途"></a>哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p>
<p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p>
<p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p>
<ul>
<li>数据库管理员能够看到用户明文口令；</li>
<li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li>
</ul>
<p>不存储用户的原始口令，那么如何对用户进行认证？</p>
<p>方法是存储用户口令的哈希，例如，MD5。</p>
<p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>
<p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p>
<table>
<thead>
<tr>
<th align="left">username</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bob</td>
<td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td align="left">alice</td>
<td align="left">25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td align="left">tim</td>
<td align="left">bed128365216c019988915ed3add75fb</td>
</tr>
</tbody></table>
<p>但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p>
<table>
<thead>
<tr>
<th align="left">常用口令</th>
<th align="left">MD5</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hello123</td>
<td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td align="left">12345678</td>
<td align="left">25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td align="left">passw0rd</td>
<td align="left">bed128365216c019988915ed3add75fb</td>
</tr>
<tr>
<td align="left">19700101</td>
<td align="left">570da6d5277a646f6552b8832012f5dc</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">20201231</td>
<td align="left">6879c0ae9117b50074ce0a0d4c843060</td>
</tr>
</tbody></table>
<p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p>
<p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p>
<p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p>
<p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p>
<p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p>
<p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">digest = md5(salt+inputPassword)</span><br></pre></td></tr></table></figure>

<p>经过加盐处理的数据库表，内容如下：</p>
<table>
<thead>
<tr>
<th align="left">username</th>
<th align="left">salt</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bob</td>
<td align="left">H1r0a</td>
<td align="left">a5022319ff4c56955e22a74abcc2c210</td>
</tr>
<tr>
<td align="left">alice</td>
<td align="left">7$p2w</td>
<td align="left">e5de688c99e961ed6e560b972dab8b6a</td>
</tr>
<tr>
<td align="left">tim</td>
<td align="left">z5Sk9</td>
<td align="left">1eee304b92dc0d105904e7ab58fd2f64</td>
</tr>
</tbody></table>
<p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p>
<h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。</p>
<p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code>&quot;SHA-1&quot;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] result = md.digest(); <span class="comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BouncyCastle"><a href="#BouncyCastle" class="headerlink" title="BouncyCastle"></a>BouncyCastle</h2><p>BouncyCastle是一个开源的第三方算法提供商；</p>
<p>BouncyCastle提供了很多Java标准库没有提供的哈希算法和加密算法；</p>
<p>使用第三方算法前需要通过<code>Security.addProvider()</code>注册。</p>
<h2 id="Hmac算法"><a href="#Hmac算法" class="headerlink" title="Hmac算法"></a>Hmac算法</h2><p>Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；</p>
<p>密钥长度由算法设计决定，AES的密钥长度是128&#x2F;192&#x2F;256位；</p>
<p>使用对称加密算法需要指定算法名称、工作模式和填充模式。</p>
<h2 id="口令加密算法"><a href="#口令加密算法" class="headerlink" title="口令加密算法"></a>口令加密算法</h2><p>PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；</p>
<p>Key通过口令和安全的随机salt计算得出，大大提高了安全性；</p>
<p>PBE算法内部使用的仍然是标准对称加密算法（例如AES）。</p>
<h2 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h2><p>DH算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。</p>
<p>DH算法没有解决中间人攻击。</p>
<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密就是加密和解密使用的不是相同的密钥，只有同一个公钥-私钥对才能正常加解密；</p>
<p>只使用非对称加密算法不能防止中间人攻击。</p>
<h2 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h2><p>数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。</p>
<p>数字签名用于：</p>
<ul>
<li>防止伪造；</li>
<li>防止抵赖；</li>
<li>检测篡改。</li>
</ul>
<p>常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>
<p>数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。</p>
<p>数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java正则表达式</title>
    <url>/2022/04/25/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式可以用字符串来描述规则，名用来匹配字符串。</p>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>正则表达式的匹配规则是从左到右按规则匹配。</p>
<ul>
<li><p>有特殊字符，那需要用<code>\</code>转义。</p>
</li>
<li><p>要匹配非Ascii字符，那就用<code>\u####</code>的十六进制表示，例如<code>\u548cc</code>匹配<code>和</code>。</p>
</li>
<li><p>匹配任意一个字符，用<code>.</code></p>
</li>
<li><p>匹配任意一个数字，用<code>\d</code></p>
</li>
<li><p>匹配任意一个字母，用<code>\w</code></p>
</li>
<li><p>匹配一个空格字符，用<code>\s</code>（包括<code>\t</code>字符）</p>
</li>
<li><p>匹配一个非数字，用<code>\D</code>（类似，<code>\W</code>，<code>\S</code>）</p>
</li>
<li><p>修饰符<code>*</code>可以匹配任意个字符。例如，用<code>A\d*</code>匹配A后面跟任意个数字</p>
</li>
<li><p>修饰符<code>+</code>可以匹配至少一个字符</p>
</li>
<li><p>修饰符<code>？</code>可以匹配0个或1个字符</p>
</li>
<li><p>修饰符<code>&#123;n&#125;</code>可以精确匹配n个字符，<code>n,m</code>匹配n~m个字符，<code>&#123;n,&#125;</code>匹配至少n个字符</p>
</li>
</ul>
<h2 id="复杂匹配规则"><a href="#复杂匹配规则" class="headerlink" title="复杂匹配规则"></a>复杂匹配规则</h2><h3 id="匹配开头或结尾"><a href="#匹配开头或结尾" class="headerlink" title="匹配开头或结尾"></a>匹配开头或结尾</h3><p>在用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如：<code>^A\d&#123;3&#125;$</code></p>
<h3 id="匹配指定范围"><a href="#匹配指定范围" class="headerlink" title="匹配指定范围"></a>匹配指定范围</h3><p>用<code>[...]</code>匹配范围内的字符串。例如：<code>[123456789]\d&#123;6,7&#125;</code>匹配非0开头的电话号码</p>
<p>字符全列出来太麻烦，<code>[...]</code>也可以写为<code>[1-9]</code></p>
<p>要六位匹配大小写不限的十六进制数，我们可以这样写：<code>[0-9a-fA-f]&#123;6&#125;</code></p>
<p><code>[...]</code>还有一种排除写法，例如：<code>[^1-9]&#123;3&#125;</code>表示不包含1-9的三位字符</p>
<h3 id="或匹配规则"><a href="#或匹配规则" class="headerlink" title="或匹配规则"></a>或匹配规则</h3><p><code>|</code>表示或，例如：<code>AB|CD</code>匹配<code>AB</code>或者<code>CD</code></p>
<h3 id="使用括号"><a href="#使用括号" class="headerlink" title="使用括号"></a>使用括号</h3><p><code>learn\\s(java|php|go)</code></p>
<h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p>例如，用正则匹配<code>区号-电话号</code>码这个规则，可以用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>
<p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p>
<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>正则表达式默认使用贪婪匹配，任何一个规则，它总是尽可能多地向后匹配。</p>
<p>在规则后面加个<code>?</code>即可表示非贪婪匹配。例如：<code>(\d+?)(0*)</code>就会用非贪婪地规则匹配<code>\d+</code></p>
<h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>如果我们要把搜索到的指定字符串按规则匹配，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的字串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java单元测试</title>
    <url>/2022/04/25/java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="编写Junit测试"><a href="#编写Junit测试" class="headerlink" title="编写Junit测试"></a>编写Junit测试</h2><p>单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对整个Java方法的测试。</p>
<p>测试驱动开发（Test-Driven Development）：是指先编写接口，紧接着编写测试，编写玩测试后，才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了。</p>
<p>如果使用main方法，不能把测试代码分离；不能打印出测试结果和期望结果；很难编写一组通用的测试代码。</p>
<p>因此，我们需要一种测试框架，帮助我们编写测试。</p>
<h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计。使用JUnit编写单元测试的好处在于，我们可以非常简单的组织测试代码，并随时运行它们。JUnit会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率。对高质量的代码来说，测试覆盖率应该在80%以上。</p>
<p>此外，几乎所有的IDE工具都继承了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactorialTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFact</span><span class="params">()</span> &#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>assertTrue()</code>: 期待结果为<code>true</code></li>
<li><code>assertFalse()</code>: 期待结果为<code>false</code></li>
<li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li>
<li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li>
<li>…</li>
</ul>
<h3 id="单元测试的好处"><a href="#单元测试的好处" class="headerlink" title="单元测试的好处"></a>单元测试的好处</h3><ul>
<li>确保单个方法正确按预期运行</li>
<li>作为示例代码，演示如何调用该方法</li>
</ul>
<h2 id="使用Fixture"><a href="#使用Fixture" class="headerlink" title="使用Fixture"></a>使用Fixture</h2><p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p>
<p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.calculator = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@AfterEach</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.calculator = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>@BeforeEach</code>和<code>@AfterEach</code>的方法会在运行每个@Test方法前后自动运行。</p>
<p>JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行，并且仅运行一次。因此，它们只能初始化静态变量。事实上，它们也只能标注在静态方法上。</p>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> <span class="title class_">Executable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>
<p>有些童鞋会觉得编写一个<code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNegative</span><span class="params">()</span> &#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述奇怪的<code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p>
<h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>可以在测试前面加注解，满足某个条件才进行的测试。</p>
<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p>
<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>
<p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再用一组负数进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAbsNegative</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数如何传入？</p>
<p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title function_">testCapitalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p>
<p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p>
<p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalize</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> &#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java时间与日期</title>
    <url>/2022/04/25/java%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="Date和Calendar"><a href="#Date和Calendar" class="headerlink" title="Date和Calendar"></a>Date和Calendar</h2><p>要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>
<h3 id="标准库API"><a href="#标准库API" class="headerlink" title="标准库API"></a>标准库API</h3><p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaIO</title>
    <url>/2022/04/25/javaIO/</url>
    <content><![CDATA[<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateCSVfile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">inFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C://in.csv&quot;</span>); <span class="comment">// 读取的CSV文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">outFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C://out.csv&quot;</span>);<span class="comment">//写出的CSV文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">inString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(inFile));</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(outFile));</span><br><span class="line">            <span class="keyword">while</span>((inString = reader.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//处理操作</span></span><br><span class="line">               writer.write(inString);</span><br><span class="line">               writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到文件！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读写文件出错！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="File对象（略）"><a href="#File对象（略）" class="headerlink" title="File对象（略）"></a>File对象（略）</h2><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>InputStream是Java标准库提供的最基本的输入流，它位于java.io这个包里。</p>
<p>注意，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已经读到末尾，则返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>
<ul>
<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>
<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>
</ul>
<p>这时read()方法的返回值是实际读取了多少个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br></pre></td></tr></table></figure>

<p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>
<h2 id="InputStream实现类"><a href="#InputStream实现类" class="headerlink" title="InputStream实现类"></a>InputStream实现类</h2><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data)) &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p>
<p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是每次写入一个字节十分麻烦，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter模式"><a href="#Filter模式" class="headerlink" title="Filter模式"></a>Filter模式</h2><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p>
<ul>
<li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li>
<li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li>
</ul>
<p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p>
<h2 id="操作Zip"><a href="#操作Zip" class="headerlink" title="操作Zip"></a>操作Zip</h2><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p>
<p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p>
<h2 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h2><p>把资源存储在classpath中可以避免文件路径依赖；</p>
<p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p>
<p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</p>
<p>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输，然后经过反序列化就可以变回Java对象。</p>
<p>一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口。Serializable接口没有定义任何方法，是一个空接口，这样的接口称为“标记接口”（Marker Interface），实现标记接口的类仅仅是给自身贴了个标记，并没有增加任何方法。</p>
<h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (ObjectInputStream input = new ObjectInputStream(...)) &#123;</span><br><span class="line">    int n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p>
<p><code>readObject()</code>可能抛出的异常有：</p>
<ul>
<li><code>ClassNotFoundException</code>：没有找到对应的Class；</li>
<li><code>InvalidClassException</code>：Class不匹配。</li>
</ul>
<p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p>
<p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p>
<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2709425275741743919L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要特别注意反序列化的几个重要特点：</p>
<p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p>
<h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p>
<table>
<thead>
<tr>
<th align="left">InputStream</th>
<th align="left">Reader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">读取字节（-1，0~255）：<code>int read()</code></td>
<td align="left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td align="left">读到字节数组：<code>int read(byte[] b)</code></td>
<td align="left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody></table>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="type">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>Reader类也有缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p>
<h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>同Reader</p>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p>
<ul>
<li><code>System.out</code>是标准输出；</li>
<li><code>System.err</code>是标准错误输出。</li>
</ul>
<p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p>
<h2 id="使用Files"><a href="#使用Files" class="headerlink" title="使用Files"></a>使用Files</h2><p>从Java 7开始，提供了<code>Files</code>这个工具类，能极大地方便我们读写文件。</p>
<p>虽然<code>Files</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = Files.readAllBytes(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content1</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content2</span> <span class="operator">=</span> Files.readString(Path.of(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>写入文件也非常方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>

<p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>
<p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合</title>
    <url>/2022/04/25/java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>List, equals方法, Map, hashCode, EnumMap, TreeMap, Properties, Set, Queue, PriorityQueue, Deque, Stack, Iterator, Collections</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2022/04/25/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p>
<span id="more"></span>

<p>例如，ArrayList就是一种模板<code>ArrayList&lt;T&gt;</code>，可以处理多种类型的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T可以是任何class。这样一来，我们编写一次模板，就可以创建任意类型的ArrayList。</p>
<h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换为需要的class类型，例如：<code>ArrayList&lt;String&gt;</code>，<code>ArrayList&lt;Number&gt;</code>等；</p>
<p>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>；</p>
<p>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型；</p>
<p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p>
<h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>编写泛型时，需要定义泛型类型<code>&lt;T&gt;</code>；</p>
<p>静态方法不能引用泛型类型<code>&lt;T&gt;</code>，必须定义其他类型（例如<code>&lt;K&gt;</code>）来实现静态泛型方法；</p>
<p>泛型可以同时定义多种类型，例如<code>Map&lt;K, V&gt;</code>。</p>
<h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<p>因此，Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>object</code>；</li>
<li>编译器根据<code>T</code>实现安全地强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p>
<p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>局限二：无法取得带泛型的<code>Class</code>。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局限三：无法判断带泛型的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p>
<p>局限四：不能实例化<code>T</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure>

<p>擦拭后实际上变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">last = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p>
<p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure>

<p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p>
<p>Java的泛型是采用擦拭法实现的；</p>
<p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>
<ul>
<li>不能是基本类型，例如：<code>int</code>；</li>
<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；</li>
<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>
<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>
</ul>
<p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p>
<p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p>
<h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>
<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>
</ul>
<p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p>
<p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p>
<ul>
<li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li>
</ul>
<h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li>
<li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li>
</ul>
<p>即使用<code>super</code>通配符表示只能写不能读。</p>
<p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p>
<p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p>
<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><p>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</p>
<p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p>
<p>可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建<code>T[]</code>数组，需要强制转型；</p>
<p>同时使用泛型和可变参数时需要特别小心。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java注解</title>
    <url>/2022/04/25/java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>注解（Annotation）时放在Java源码的类、方法、字段、参数前的一种特殊“注释”。<br>注解可以被编译器打包进入class文件。因此，注解是一种用作标注的“元数据”。</p>
<span id="more"></span>

<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>Java的注解可以分为三类：</p>
<p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>
<p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p>
<p>如果只写注解，相当于全部使用默认值。</p>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）</p>
<p>Java使用<code>@interface</code>定义注解：</p>
<p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p>
<p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p>
<p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>可以通过程序处理注解来实现相应的功能：</p>
<ul>
<li>对JavaBean的属性值按规则进行检查；</li>
<li>JUnit会自动运行<code>@Test</code>标记的测试方法。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2022/04/25/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。<br>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    String <span class="title function_">getFullName</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果不能获得Person类，只有一个Object实例，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么办？有童鞋会说：强制转型啊！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getFullName</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用Person类。不然，去掉import语句，你看能不能编译通过？</p>
<p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。</p>
<p>每加载一种class，JVM就为其创建一个Class类型的实例。</p>
<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p>一个Class实例包含了该class的所有完整信息。</p>
<p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>
<p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p>
<p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。</p>
<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printObjectInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</p>
<h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p><code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>略</p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = new Person();</span><br></pre></td></tr></table></figure>

<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>
<p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>略</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？</p>
<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常处理</title>
    <url>/2022/04/25/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p>在计算机运行的过程中，会有各种错误。Java内置了一套异常处理机制，总是使用异常来表示错误。异常是一种class，本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了。</p>
<p>因为Java的异常是class，它的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>Error表示很严重的错误，程序一般对此无能为力。Exception是运行时的错误，它可以被捕获并处理。</p>
<p>Java规定：</p>
<ul>
<li>必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常陈伟Checked Exception。</li>
<li>不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用<code>try...catch</code>语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h2><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p>
<p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用或者<code>|</code>来选择多种异常</p>
<h2 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h2><p>无论代码是否发生异常，都会执行finally语句。</p>
<ul>
<li>finally语句不是必须的，可写可不写。</li>
<li>finally语句总是最后执行。</li>
</ul>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
<h2 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h2><p>如果在finally语句时抛出异常，那么，catch语句中的异常不能正确抛出。</p>
<p>需要通过Throwable.getSuppressed()获取所有的Suppressed Exception。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java标准库定义的常用异常包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure>

<p>可以自定异常。</p>
<h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果断言失败，则抛出<code>AssertionError</code>。</p>
<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p>
<h2 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h2><p>日志包<code>java.util.logging</code></p>
<h2 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h2><h2 id="使用Log4j"><a href="#使用Log4j" class="headerlink" title="使用Log4j"></a>使用Log4j</h2><h2 id="使用SLF4J和Logback"><a href="#使用SLF4J和Logback" class="headerlink" title="使用SLF4J和Logback"></a>使用SLF4J和Logback</h2>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java核心类</title>
    <url>/2022/04/24/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>字符串是不可变的，存储来常量池中。</p>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1.equals(s2);</span><br><span class="line">s1.equalsIgnoreCase(s2);</span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>);<span class="comment">//true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;,移除首尾空格、换行符、制表符</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>

<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123; <span class="comment">//链式操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个链式操作的类（方法返回this）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adder</span>();</span><br><span class="line">        adder.add(<span class="number">3</span>)</span><br><span class="line">             .add(<span class="number">5</span>)</span><br><span class="line">             .inc()</span><br><span class="line">             .add(<span class="number">10</span>);</span><br><span class="line">        System.out.println(adder.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Adder <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        sum ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>

<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>我们已经知道，java的数据类型分为两种：</p>
<ul>
<li>基本类型：byte，short，int，long，boolean，float，double，char</li>
<li>引用类型：所有的class和interface类型</li>
</ul>
<p>引用类型可以赋值为null，表示空，但基本类型不能赋值为null。</p>
<p>那么，如何把一个基本类型视为对象（引用类型）？</p>
<p>比如，想把int变为引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样Integer类就可以视为int的包装类（Wrapper Class）</p>
<p>Java核心库为每种类型都提供了对应的包装类型：</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<h3 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>

<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p>
<h3 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h3><p>所有的包装都是不变类，一旦创建该对象就是不变的。用equals()比较。</p>
<p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li>方法1：<code>Integer n = new Integer(100);</code></li>
<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>
</ul>
<p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
<p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
<p><strong>创建新对象时，优先选用静态工厂方法而不是new操作符。</strong></p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>在Java中，有很多class的定义都符合这样的规范：</p>
<ul>
<li>若干private实例字段</li>
<li>通过public方法来读写实例字段（get，set方法）</li>
</ul>
<p>如果读写方法符合这样的规范，那么这种class就称为JavaBean</p>
<h3 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h3><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。通过IDE，可以快速生成getter和setter。</p>
<h2 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为枚举类的比较和赋值要符合相同类型，这样就使得编译器可以在编译期自动检查除可能的潜在错误。</p>
<h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><p>使用enum定义的枚举类是一种引用类型，引用类型的比较需要使用equals()方法，如果使用&#x3D;&#x3D;比较，会比较两个引用类型的变量是否指向同一对象。但是，<strong>enum类型可以例外</strong>。</p>
<p>这是因为enum类型的每个变量在JVM中只有一个唯一实例，所以可以直接用&#x3D;&#x3D;比较。</p>
<h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p>enum枚举类和其他的class有什么区别？</p>
<p>答案是没有区别。enum定义的类型就是class，只不过有一下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h3><p>返回常量名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h3><p>返回定义的常量的顺序，从0开始计数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>改变枚举常量的顺序会导致变化。</p>
<p>可以定义private构造方法，并且给每个枚举常量添加字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就无需担心顺序的变化。</p>
<p>可以给enum类型添加toString方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue, String chinese)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="built_in">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样输出时更有可读性。</p>
<p><strong>判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</strong></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，因此更适合用在switch中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加上default语句，可以在漏写，某个枚举常量时自动报错，从而及时发现错误。</p>
<h2 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h2><p>使用String，Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ul>
<li>定义class时使用final，无法派生子类</li>
<li>每个字段使用final，保证创建实例后无法修改任何字段</li>
</ul>
<p>如果我们需要定义一个不变类point，除了要将变量改为final外，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。这些代码写起来都非常简单，但是很繁琐。</p>
<h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>从Java14开始，引入了新的Record类。我们定义Record类时，使用关键字record。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>point的定义如果改为class，相当于一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString(), equals()和hashCode()方法。</p>
<p>换句话说，使用record关键字，可以一行写出一个不变类。</p>
<p>和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么如果我们要检查参数，应该怎么办？</p>
<p>比如x,y不允许负数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到方法public Point{…}被称为Compact Constructor，它的目的时让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为record的Point仍然可以添加静态方法。一种常用的静态方法时of()方法，用来创建Point：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们可以写出更简洁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">z</span> <span class="operator">=</span> Point.of();</span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p><code>java.math.BigInteger</code>用来表示任意大小的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>

<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>

<p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p>
<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>

<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p>
<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>可以表示一个任意大小且精度完全准确的浮点数。</p>
<p><strong>用compareTo()比较两个BigDecimal的值，不要使用equals()！</strong></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><ul>
<li>Math</li>
<li>Random</li>
<li>SecureRandom</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>理解java-Class.forname()</title>
    <url>/2022/04/23/%E7%90%86%E8%A7%A3java-Class-forname/</url>
    <content><![CDATA[<p><strong>Class 类概念</strong></p>
<p>Class 也是一个 Java 类，保存的是与之对应 Java 类的 meta信息（元信息），用来描述这个类的结构，比如描述一个类有哪些成员，有哪些方法等，一般在反射中使用。</p>
<span id="more"></span>

<p><strong>详细解释：</strong>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例（Class 对象）。也就是说，在 Java 中，每个 java 类都有一个相应的 Class 对象，用于表示这个 java 类的类型信息。</p>
<p><strong>类加载概念</strong></p>
<p>当使用一个类的时候（比如 new 一个类的实例），会检查此类是否被加载到内存，如果没有，则会执行加载操作。</p>
<p>读取类对应的 class 文件数据，解析此数据，构造一个此类对应的 Class 类的实例。此时JVM就可以使用该类了，比如实例化此类，或者调用此类的静态方法。</p>
<p>Java 也提供了手动加载类的接口，class.forName()方法就是其中之一。（说来说去，其实就是生成这个类的 Class）</p>
<p><strong>类加载器的概念</strong></p>
<p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance() 方法就可以创建出该类的一个对象。 基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p>
<p><strong>类初始化概念</strong></p>
<p>类被加载之后，jvm 已经获得了一个描述类结构的 Class 实例。但是还需要进行类初始化操作之后才能正常使用此类，类初始化操作就是执行一遍类的静态语句，包括静态变量的声明还有静态代码块。</p>
<p><strong>Class.forName() 方法</strong></p>
<p>此方法含义是：加载参数指定的类，并且初始化它。</p>
<p>在 jdbc 连接数据库中的应用</p>
<p>到这里，不用解释，读者也会明白，在使用 jdbc 方式连接数据库时，为什么要执行 <strong>Class.forName(‘驱动类名’)</strong> 方法了：将驱动类的 class 文件装载到内存中，并且形成一个描述此驱动类结构的 Class 类实例，并且初始化此驱动类，这样 jvm 就可以使用它了，这就是 Class.forName() 方法的含义。</p>
<p>有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用 newInstance() 方法呢？即有的 jdbc 连接数据库的写法里是 Class.forName(xxx.xx.xx);而有一 些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？</p>
<p>刚才提到，<strong>Class.forName(“”);</strong> 的作用是要求 JVM 查找并加载指定的类，如果在类中有静态初始化器的话，JVM 必然会执行该类的静态代码 段。而在 JDBC 规范中明确要求这个 Driver 类必须向 DriverManager 注册自己，即任何一个 JDBC Driver 的 Driver 类的代码都必须类似如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJDBCDriver</span> <span class="keyword">implements</span> <span class="title class_">Driver</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">MyJDBCDriver</span>()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>既然在静态初始化器的中已经进行了注册，所以我们在使用 JDBC 时只需要 <strong>Class.forName(XXX.XXX);</strong> 就可以了。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring教程 Day4</title>
    <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day4/</url>
    <content><![CDATA[<p>本文为spring教程笔记4，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p>
<span id="more"></span>

<h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>Spring的事务控制</p>
<h3 id="spring中基于注解的声明式事务控制配置步骤"><a href="#spring中基于注解的声明式事务控制配置步骤" class="headerlink" title="spring中基于注解的声明式事务控制配置步骤"></a>spring中基于注解的声明式事务控制配置步骤</h3><p>1.配置事务管理器</p>
<p>2.开启spring对注解事务的支持</p>
<p>3.在需要事务支持的地方使用@Transactional注解</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring教程 Day3</title>
    <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day3/</url>
    <content><![CDATA[<p>本文为spring教程笔记3，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p>
<span id="more"></span>

<h2 id="Day3-Spring-面向切面（AOP）"><a href="#Day3-Spring-面向切面（AOP）" class="headerlink" title="Day3 Spring 面向切面（AOP）"></a>Day3 Spring 面向切面（AOP）</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>特点：字节码随用随创建，随用随加载</li>
<li>作用：不修改源码的基础上对方法增强</li>
<li>分类：</li>
<li><ul>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ul>
</li>
<li><strong>1.基于接口的动态代理：</strong></li>
<li><ul>
<li>涉及的类：Proxy</li>
<li>提供者：JDK官方</li>
<li>如何创建代理对象：</li>
<li><ul>
<li>使用Proxy类中的newProxyInstance方法</li>
</ul>
</li>
<li>创建代理类的要求：被代理类最少实现一个接口，如果没有则不能使用</li>
<li>newProxyInstance方法的参数：</li>
<li><ul>
<li>ClassLoader：类加载器。它是用于加载代理对象字节码的，和被代理对象使用相同的类加载器。固定写法。</li>
</ul>
</li>
<li>Class[]：字节码数组。它是用于让代理对象和被代理对象有相同方法、固定写法。</li>
<li>InvocationHandler：用于提供增强的代码。他是让我们写如何代理。一般都是写一个该接口的实现类，通常情况下都是匿名内部类。但不是必须的。此接口的实现类都是谁用谁写。</li>
</ul>
</li>
<li><strong>2.基于子类的动态代理</strong></li>
<li><ul>
<li>涉及的类：Enhance</li>
<li>提供者：第三方cglib库</li>
<li>如何创建代理对象：</li>
<li><ul>
<li>使用Enhance类中的create方法</li>
</ul>
</li>
<li>创建代理对象的要求：被代理类不能是最终类</li>
<li>create方法的参数：</li>
<li><ul>
<li>class：字节码。它是指定被代理对象的字节码</li>
<li>Callback：用于提供增强的代码。他是让我们写如何代理。一般都是写一个该接口的实现类，通常情况下都是匿名内部类。但不是必须的。此接口的实现类都是谁用谁写。我们一般写的都是该接口的子接口实现类：MethodIntercepter</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="spring中基于XML的AOP配置步骤"><a href="#spring中基于XML的AOP配置步骤" class="headerlink" title="spring中基于XML的AOP配置步骤"></a>spring中基于XML的AOP配置步骤</h3><p>1.把通知Bean也交给spring来管理</p>
<p>2.使用aop：config标签表明开始AOP的配置</p>
<p>3.使用aop：aspect标签表明配置切面</p>
<p>​        id属性：是给切面提供一个唯一标识</p>
<p>​        ref属性：是指定通知类bean的id</p>
<p>4.在aop：aspect标签的内部使用对应标签来配置通知的类型</p>
<p>​        我们现在示例是让printlog方法在切入点方法执行之前，所以是前置通知</p>
<p>​        aop：before：表示配置前置通知</p>
<p>​            method属性：用于指定logger类中哪个方法是前置通知</p>
<p>​            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</p>
<p>​        切入点表达式的写法：</p>
<p>​            关键字：execution（表达式）</p>
<p>​            表达式：访问修饰符 返回值 包名.包名.包名…类名.方法名（参数列表）</p>
<p>​            标准的表达式写法：</p>
<p>​                <code>public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</code></p>
<p>​            访问修饰符可以省略（去掉public）</p>
<p>​            返回值可以使用通配符，表示任意返回值（void改为*）</p>
<p>​            包名可以使用通配符，表示任意包。但是有几级包，就要写几个*.</p>
<p>​            包名可以用..表示当前包及其子包</p>
<p>​            类名和方法名都可以使用*表示通配</p>
<p>​            参数列表：</p>
<p>​                可以直接写数据类型（基本类型直接写名称(int)，引用类型写包名、类名的方式（java.lang.String))</p>
<p>​                可以使用通配符表示任意类型，但是必须有参数</p>
<p>​                可以使用..表示有无参数均可，有参数可以是任意类型</p>
<p>​            全通配写法：<code>* *..*.*(..)</code></p>
<p>​            实际开发中切入点表达式的通常写法：切到业务层实现类下的所有方法：<code>.com.itheima.service.impl.*.*(..)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Logger类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;printlog&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.itheima.service.impl.AccountServiceImpl.saveAccount())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="四种常用的通知类型"><a href="#四种常用的通知类型" class="headerlink" title="四种常用的通知类型"></a>四种常用的通知类型</h3><ul>
<li>前置通知：before</li>
<li>后置通知：after-returning</li>
<li>异常通知：after-throwing</li>
<li>最终通知：after</li>
</ul>
<h3 id="spring中的环绕通知"><a href="#spring中的环绕通知" class="headerlink" title="spring中的环绕通知"></a>spring中的环绕通知</h3><p>问题：当配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</p>
<p>分析：通过对比动态代理中的环绕代码， 发现动态代理的环绕通知有明确的切入点调用，而我们的代码中没有</p>
<p>解决：Spring框架为我们提供了一个接口：ProceedingJoinPoint，该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</p>
<p>环绕通知：它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring教程 Day2</title>
    <url>/2022/04/22/Spring%E6%95%99%E7%A8%8B-Day2/</url>
    <content><![CDATA[<p>本文为spring教程笔记2，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p>
<span id="more"></span>

<h2 id="Day2-spring基于注解的IOC以及IOC的案例"><a href="#Day2-spring基于注解的IOC以及IOC的案例" class="headerlink" title="Day2 spring基于注解的IOC以及IOC的案例"></a>Day2 spring基于注解的IOC以及IOC的案例</h2><h3 id="spring中IOC常用注解"><a href="#spring中IOC常用注解" class="headerlink" title="spring中IOC常用注解"></a>spring中IOC常用注解</h3><ul>
<li><p>用于创建对象的</p>
</li>
<li><ul>
<li><p>他们的作用就和在xml配置文件中编写一个bean标签实现的功能是一样的</p>
</li>
<li><p>@Component</p>
</li>
<li><ul>
<li>作用：把当前类对象存入spring容器中</li>
<li>属性：</li>
<li><ul>
<li>value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</li>
</ul>
</li>
</ul>
</li>
<li><p>告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中。(也就是要改一下bean标签，然后在里面有一个context标签)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:coomponent-scan</span> <span class="attr">base-packet</span>=<span class="string">&quot;con.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:coomponent-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>@Controller，一般用在表现层</p>
</li>
<li><p>@Service，一般用于业务层</p>
</li>
<li><p>@Repository，一般用于持久层</p>
</li>
<li><p>以上三个注解它们的作用和属性和Component是一模一样的。它们三个时spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰。</p>
</li>
</ul>
</li>
<li><p>用于注入数据的</p>
</li>
<li><ul>
<li>他们的作用就和xml配置文件中的bean标签中写一个property标签的作用是一样的</li>
<li>@Autowired</li>
<li><ul>
<li>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。如果没有任何匹配，则报错。如果IOC去容器中有多个匹配，如果名字相同于匹配对象则注入成功，否则失败。</li>
<li>出现位置：可以是变量上，也可以是方法上</li>
<li>细节：在使用注解注入时，set方法不是必须的了</li>
</ul>
</li>
<li>Qualifier：</li>
<li><ul>
<li>作用：在按照类注入的基础上再按照名称注入。它在给类成员注入时不能单独使用（要和Autowired配合），但是在给方法参数注入时可以</li>
<li>属性：</li>
<li><ul>
<li>value：用于指定注入bean的id</li>
</ul>
</li>
</ul>
</li>
<li>Resource：</li>
<li><ul>
<li>作用：直接按照bean的id注入，可以独立使用</li>
<li>属性：</li>
<li><ul>
<li>name：用于指定bean的id</li>
</ul>
</li>
</ul>
</li>
<li>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现</li>
<li>@Value</li>
<li><ul>
<li>作用：用于注入基本类型和String类型的数据</li>
<li>属性：</li>
<li><ul>
<li>value：用于指定数据的值。它可以使用spring中的SpEL（也就是spring中的el表达式）。</li>
<li>SpEL的写法：${表达式}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用于改变作用范围的</p>
</li>
<li><ul>
<li>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</li>
<li>@Scope</li>
<li><ul>
<li>作用：用于指定bean的作用范围</li>
<li>属性</li>
<li><ul>
<li>value：用于指定范围的取值。常用取值：singleton，prototype</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>和生命周期相关的（了解）</p>
</li>
<li><ul>
<li><p>他们的作用就和在bean标签中使用init-method和destroy-method的作用是一样的</p>
</li>
<li><p>@PreDestroy</p>
</li>
<li><ul>
<li>作用：用于指定销毁方法</li>
</ul>
</li>
<li><p>@PostConstruct</p>
</li>
<li><ul>
<li>作用：用于指定初始化方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring配置类"><a href="#Spring配置类" class="headerlink" title="Spring配置类"></a>Spring配置类</h3><ul>
<li>@configuration</li>
<li><ul>
<li>作用：指定当前类是一个配置类</li>
</ul>
</li>
<li>@ComponentScan</li>
<li><ul>
<li>作用：用于通过注解指定的spring在创建容器时要扫描的包</li>
<li>属性：</li>
<li><ul>
<li>value、basePackages：作用时一样的，都是用于指定创建容器时要扫描的包。使用此注解就等同于在XML文件中配置了component-scan。</li>
</ul>
</li>
<li>当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注释可以不写。</li>
</ul>
</li>
<li>@Bean</li>
<li><ul>
<li>作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</li>
<li>属性：</li>
<li><ul>
<li>name：用于指定bean的id，不写时默认是当前方法的名称</li>
</ul>
</li>
<li>当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。</li>
</ul>
</li>
<li>@import</li>
<li><ul>
<li>作用：用于导入其他的配置类</li>
<li>属性：</li>
<li><ul>
<li>value：用于指定其他配置类的字节码。当我们使用Import注解之后，有import注解的类就是父配置类，导入的就是子配置类。</li>
</ul>
</li>
</ul>
</li>
<li>@PropertySource</li>
<li><ul>
<li>作用：用于指定properties文件的位置</li>
<li>属性</li>
<li><ul>
<li>value：指定文件的名称和路径</li>
<li>关键字：classpath，表示类路径下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="spring整合Junit"><a href="#spring整合Junit" class="headerlink" title="spring整合Junit"></a>spring整合Junit</h3><p>1.导入spring整合junit的jar（坐标）</p>
<p>2.使用junit提供的一个注解把原有的main方法替换了，换成spring提供的@Runwith</p>
<p>3.告诉spring的运行器，spring的ioc创建是基于xml还是注解的，并且说明位置。@contextConfiguration：</p>
<p>​    locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</p>
<p>​    classes：指定注解类所在的位置</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>C++高级程序设计-学习小记</title>
    <url>/2022/04/22/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring教程 Day1</title>
    <url>/2022/04/21/Spring%E6%95%99%E7%A8%8B%20Day1/</url>
    <content><![CDATA[<p>本文为spring教程笔记，视频资源为b站黑马程序员<a href="https://www.bilibili.com/video/BV1Sb411s7vP?p=1%E3%80%82">https://www.bilibili.com/video/BV1Sb411s7vP?p=1。</a></p>
<span id="more"></span>

<h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="spring连接数据库的过程："><a href="#spring连接数据库的过程：" class="headerlink" title="spring连接数据库的过程："></a>spring连接数据库的过程：</h3><p>1.注册驱动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">Class.forname(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2.获取连接</p>
<p><code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test1&quot;,&quot;root&quot;,&quot;123456&quot;);</code>    </p>
<p>3.获取操作数据库的预处理对象</p>
<p><code>PreparedStatement pstm = conn.prepareStatement(&quot;select * from test1&quot;);</code></p>
<p>4.执行SQL，得到结果集</p>
<p><code>ResultSet rs = pstm.excuteQuery();</code></p>
<p>5.遍历结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">	system.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">pstm.close();</span><br><span class="line">conn.closse();</span><br></pre></td></tr></table></figure>

<h3 id="在cmd中使用mysql"><a href="#在cmd中使用mysql" class="headerlink" title="在cmd中使用mysql"></a>在cmd中使用mysql</h3><p><code>mysql -uroot -p123456</code><br>然后就可以使用sql语句对数据库进行操作<br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test1；</span><br><span class="line">use test1；</span><br></pre></td></tr></table></figure>

<p>这样之后的sql语句都是在test1这个database中进行操作的。</p>
<h3 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h3><p>即程序间的依赖关系</p>
<ul>
<li>类之间的依赖</li>
<li>方法间的依赖</li>
</ul>
<p>解耦：降低程序间的依赖关系</p>
<p>实际开发中应该做到：编译期不依赖，运行时才依赖。</p>
<p>解耦的思路：</p>
<p>第一步：使用反射来创建对象，而避免使用new关键字</p>
<p>第二部：通过读取配置文件来获取要创建的对象全限定类名</p>
<h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>三层模型：业务层，持久层，展示层</p>
<p>Bean：可重用组件的含义</p>
<p>一个创建Bean对象的工厂：它就是创建service和dao对象的</p>
<p>第一个：需要一个配置文件来配置我们的service和dao</p>
<p>​        配置的内容：唯一标志&#x3D;全限定类名（key&#x3D;value）</p>
<p>第二个：通过读取配置文件中配置的内容，反射创建对象</p>
<p>配置文件可以是xml也可以是propertices</p>
<p>定义一个properties对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Properties props;</span><br></pre></td></tr></table></figure>

<p>使用静态代码块为Properties对象赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static</span><br><span class="line">	try&#123;</span><br><span class="line">		//实例化对象</span><br><span class="line">		props = new Propertices();</span><br><span class="line">		//获取properties文件的流对象</span><br><span class="line">		InoutStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);</span><br><span class="line">		props.load(in);</span><br><span class="line">	&#125;catch(Exception e)&#123;</span><br><span class="line">		throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Bean的名称获取bean对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br></pre></td></tr></table></figure>

<p>创建的对象要改为单例模式</p>
<p>对工厂模式的理解：工厂模式就是接管APP和资源的联系，由工厂控制资源的联系，并将资源提供给APP，断开了APP和资源间的依赖关系。（提供对象的名字，由工厂来从仓库中找出来）（Inversion of Control，IOC，控制反转，将对象的控制权转移给工厂）</p>
<h2 id="Spring基于IOC的XML开发环境"><a href="#Spring基于IOC的XML开发环境" class="headerlink" title="Spring基于IOC的XML开发环境"></a>Spring基于IOC的XML开发环境</h2><p>导入spring-context依赖</p>
<p>resources里面新建xml文件，导入约束，然后创建bean标签，把对象的创建交给spring管理。</p>
<p>获取spring的Ioc核心容器，并根据id获取对象</p>
<p>ApplicationContext的三个常用实现类：</p>
<ul>
<li><p>ClassPathXmlApplicationContext：它可以加载路径下的配置文件，要求配置文件必须在类路径下。不然加载不了。</p>
</li>
<li><p>FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件。</p>
</li>
<li><p>AnnotationConfigAppllicationContext：它是用于读取注解创建容器的。</p>
</li>
</ul>
<p>核心容器的两个接口引发的问题：</p>
<p>ApplicationContext： 单例对象适用</p>
<ul>
<li>它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象</li>
</ul>
<p>BeanFactory： 多例对象适用</p>
<ul>
<li>它在构建核心容器时，创建对象采取的策略是采用延时加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正创建对象。</li>
</ul>
<h2 id="Spring中的bean"><a href="#Spring中的bean" class="headerlink" title="Spring中的bean"></a>Spring中的bean</h2><h3 id="Bean对象创建的三种方式"><a href="#Bean对象创建的三种方式" class="headerlink" title="Bean对象创建的三种方式"></a>Bean对象创建的三种方式</h3><ul>
<li><p>1.使用默认构造函数创建</p>
</li>
<li><ul>
<li><p>在Spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</p>
</li>
<li><p>&#96;&#96;&#96;xml<br><bean id="accountService" class="com.itheima.factory.InstanceFactory"></bean></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    通过读取这个全限定类名，反射创建一个对象，并且存入Spring核心容器中。</span><br><span class="line"></span><br><span class="line">* 2.使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</span><br><span class="line"></span><br><span class="line">* * ```xml</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>3.使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）</p>
</li>
<li><ul>
<li>&#96;&#96;&#96;xml<br><bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="getAccountService"></bean><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Bean对象的作用范围</span><br><span class="line"></span><br><span class="line">bean标签的scope属性：</span><br><span class="line"></span><br><span class="line">* 作用：用于指定bean的作用范围</span><br><span class="line">* 取值</span><br><span class="line">* * singleton：单例的（默认值）</span><br><span class="line">  * prototype：多例的</span><br><span class="line">  * request：作用于web应用的请求范围</span><br><span class="line">  * session：作用于web应用的会话范围</span><br><span class="line">  * global-session：作用域集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session。 </span><br><span class="line"></span><br><span class="line">### Bean对象的生命周期</span><br><span class="line"></span><br><span class="line">单例对象：</span><br><span class="line"></span><br><span class="line">* 出生，当容器创建时对象出生</span><br><span class="line">* 活着，只要容器还在，对象一直活着</span><br><span class="line">* 死亡，容器销毁，对象消亡</span><br><span class="line">* 总结：单例对象的生命周期和容器相同</span><br><span class="line"></span><br><span class="line">多例对象：</span><br><span class="line"></span><br><span class="line">* 出生，当使用对象时spring框架为我们创建</span><br><span class="line">* 活着，对象只要在使用过程中就一直活着</span><br><span class="line">* 死亡，当对象长时间不用，且没有别的对象引用时，由Java垃圾回收器回收</span><br><span class="line"></span><br><span class="line">## Spring中的依赖注入</span><br><span class="line"></span><br><span class="line">依赖注入：Dependency Injection</span><br><span class="line"></span><br><span class="line">IOC的作用：降低程序间的耦合（依赖关系）</span><br><span class="line"></span><br><span class="line">依赖关系的管理：以后都交给spring来维护</span><br><span class="line"></span><br><span class="line">在当前类需要用到其他类的对象，由spring来为我们提供，我们只需要在配置文件中说明。</span><br><span class="line"></span><br><span class="line">依赖关系的维护：就称之为依赖注入。</span><br><span class="line"></span><br><span class="line">依赖注入：能注入的数据有三类：</span><br><span class="line"></span><br><span class="line">* 基本类型和String</span><br><span class="line">* 其他bean类型（在配置文件中或者注解配置过的bean）</span><br><span class="line">* 复杂类型/集合类型</span><br><span class="line"></span><br><span class="line">注入的方式有三种：</span><br><span class="line"></span><br><span class="line">* 使用构造函数提供</span><br><span class="line"></span><br><span class="line">* * 使用的标签：constructor-arg</span><br><span class="line"></span><br><span class="line">  * 标签出现的位置：bean标签的内部</span><br><span class="line"></span><br><span class="line">  * 标签中的属性：</span><br><span class="line"></span><br><span class="line">  * * type：用于指定要注入的数据的数据类型，该主句类型也是构造函数中某个或某些参数的类型。</span><br><span class="line">    * index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置从0开始。</span><br><span class="line">    * name：用于指定给构造函数中指定名称的参数赋值。（常用）</span><br><span class="line">    * value：用于提供基本类型和String类型的数据</span><br><span class="line">    * ref：用于指定其他的bean类型数据。它指的就是在Spring的Ioc核心容器中出现过的bean对象。</span><br><span class="line"></span><br><span class="line">  * 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</span><br><span class="line"></span><br><span class="line">  * 弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</span><br><span class="line"></span><br><span class="line">  * ```xml</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.imp.AccountService&quot;&gt;</span><br><span class="line">    	&lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;birthday&quot; reg=&quot;now&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;！--配置一个日期对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用set方法提供（更常用）</p>
</li>
<li><ul>
<li>涉及的标签：property</li>
<li>出现的位置：bean标签的内部</li>
<li>标签的属性：</li>
<li><ul>
<li>name：用于指定注入时所调用的set方法名称</li>
<li>value：用于提供基本类型和String类型的数据</li>
<li>ref：用于指定其他的bean类型数据。</li>
</ul>
</li>
<li>优势：创建对象时没有明确的限制，可以直接使用默认构造函数</li>
<li>弊端：如果某个成员必须有值，则获取对象时有可能set方法没有执行</li>
<li>&#96;&#96;&#96;xml<bean id="accountService2" class="com.itheima.service.impl.AccountServiceImpl2">
    <property name="name" value="TEST"></property>
    <property name="age" value="21"></property>
    <property name="birthday" ref="new"></property>
</bean>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 复杂类型的注入/集合类型的注入</span><br><span class="line"></span><br><span class="line">* * 用于给list结构集合注入的标签：list，array，set</span><br><span class="line">  * 用于给map结构集合注入的标签：map，props</span><br><span class="line">  * 结构相同，标签可以互换</span><br><span class="line"></span><br><span class="line">* ```xml</span><br><span class="line">  &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;</span><br><span class="line">  	&lt;property name=&quot;myStrs&quot;&gt;</span><br><span class="line">      	&lt;array&gt;</span><br><span class="line">          	&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">              &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">              &lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">          &lt;/array&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用注解提供</p>
</li>
</ul>
<p>（IDEA可以用alt+insert快速生成构造函数）</p>
<p>如果是经常变化的数据，并不适用于注入的方式。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>看板开发方法</title>
    <url>/2022/04/21/%E7%9C%8B%E6%9D%BF%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>看板开发方法是近年来（2013年）最热门的敏捷和精益开发方法。越来越多的案例表明，它能够改善协作、优化管理、显著提高交付速度、质量和灵活性。看板开发方法的规则简单，但其有效实施依赖于对原理的理解、对原则的坚持和实践的应变。</p>
<span id="more"></span>
<h2 id="1-看板的原始含义"><a href="#1-看板的原始含义" class="headerlink" title="1.看板的原始含义"></a>1.看板的原始含义</h2><h3 id="原始定义"><a href="#原始定义" class="headerlink" title="原始定义"></a>原始定义</h3><p>看板源自精益制造，从丰田公司的事件中演化出来，要求准时化、自动化，提供高质量、低成本、快速响应的产品。<br>看板一词源自日文，本义是可视化卡片（硅谷（Silicon Valley）电视剧中即使用看板开发）。看板工具的实质是：后道工序在需要时，通过看板向前道工序发出信号——请告诉我需要数量的输入，前道工序只有得到看板后，才按需生产。看板信号由下游向上游传递，拉动上有的生产活动，时产品向下游移动。拉动的源头是最下游的客户价值，也就是客户订单或需求。</p>
<h3 id="基于看板的拉动系统实现准时化"><a href="#基于看板的拉动系统实现准时化" class="headerlink" title="基于看板的拉动系统实现准时化"></a>基于看板的拉动系统实现准时化</h3><p>准时化又叫即时生产（Just in time - JIT）是丰田生产方式的一个支柱。看板形成拉动系统，各环节根据看板信息，尽在需要的时间生产需要的数量的必要产品。这带来身缠库存的降低，降低了成本，缩短了交付周期，提高了制造过程的灵活性。</p>
<h2 id="2-精益产品开发"><a href="#2-精益产品开发" class="headerlink" title="2.精益产品开发"></a>2.精益产品开发</h2><h3 id="价值流动"><a href="#价值流动" class="headerlink" title="价值流动"></a>价值流动</h3><p><img src="https://static001.infoq.cn/resource/image/93/8b/93cc49843b45dd772627527c8423228b.png"></p>
<p>图中每个卡片代表一个价值项，如：功能需求、缺陷、技术概念验证等。他们所在的列，表示其所处的阶段。这些价值项，每经过一个阶段（图中的列）都会产生新信息，价值得以增加。</p>
<p>价值流动可能会被阻碍，比如，编码因对第三方接口错误而无法进展；测试因没有设备而停止。图中，红色卡片是对问题和阻碍地可视化。标识阻碍因素并推动其解决，促进价值流动。</p>
<p>最终限制系统端到端流量是系统瓶颈处的流量，改善端到端地价值流，必须从解决瓶颈问题开始。发现看板墙上的瓶颈并不困难，找到最长的队列就可以了。上图最长的队列出现在测试处，不难看出，测试是价值流动的瓶颈。</p>
<p>价值、价值流，以及问题和瓶颈的可视化，是改善价值的起始，也是其他看板实践的基础。</p>
<h3 id="显式化流程规则"><a href="#显式化流程规则" class="headerlink" title="显式化流程规则"></a>显式化流程规则</h3><p>显式化流程规则，是指明确定义和沟通团队所遵循的流程规则。价值项的“流传规则”是看板开发方法中最典型的流程规则。它定义了一个价值项从一个阶段进入下一个阶段所必须达到的标准。下图中，给出了某团队其中一项流传规则的实例，定义了从分析阶段进入开发阶段所必须达到的条件。</p>
<p><img src="https://static001.infoq.cn/resource/image/5b/5f/5b9816d08795bb9f15915fae65a8325f.png"></p>
<p>“流传规则”的显式化，让质量内建于各个阶段——这与精益制造中内建质量的思想是一致的。除各个“流转规则”外，其他重要的流程规则也可以或者需要被显式化，如，团队的写作规则、优先级的定义规则等。</p>
<p>流程显式化更重要的意义在于，它是“持续改进”的出发点和结果的载体。没有显式化的规则作为依据，讨论改进就没有基础，而变得主观和随意。改进的结果通常也需要落实到显式的流程规则当中，让改进稳步进行，避免低效的反复。显式化规则不是为了限定团队的工作方式，而是为了帮助团队更好地改进。</p>
<h3 id="限制在制品数量"><a href="#限制在制品数量" class="headerlink" title="限制在制品数量"></a>限制在制品数量</h3><p>限制在制品数量是看板开发的核心机制。如下图所示，列标题右边的数字标识了该阶段允许的在制品的最大数目（进行中和完成的价值项的和）。在制品数量小于这个数字时，才可以从前一阶段拉入新的工作。图中，分析阶段的在制品限制数目时3，而实际在制品数目时2，可以拉入新的工作。</p>
<p><img src="https://static001.infoq.cn/resource/image/34/56/3466798c64aad3bea321ded453853356.png"></p>
<p>限制在制品数量形成一个与精益制造类似的拉动机制。一个环节有空余的能力（在制品数量未达上限）时，从上游拉入新的工作，拉动的源头时最下游的交付或客户需求。与产品制造类似，通过拉动系统可以加速价值流动和暴露问题。</p>
<h3 id="度量和管理流动"><a href="#度量和管理流动" class="headerlink" title="度量和管理流动"></a>度量和管理流动</h3><p>快速、顺畅的价值流动是看板开发的目标。快速流动带来的价值产出和快速反馈，它对业务成功至关重要：顺畅流动，意味着稳定和可预测的价值交付能力，这与流动的绝对速度同等重要。</p>
<p><img src="https://static001.infoq.cn/resource/image/30/fc/30ae4cdb21c2d518fabdf6563e37f9fc.png"></p>
<p>度量为改善价值流动提供方向参考，同时为改善的结果提供反馈。看板开发方法没有定义特定的度量方法，累积流量图是实际应用较为普遍的一种。图 ㈨是一个典型的累积流量图，左面的斜线是累积已经开始的价值项（如用户需求）数目，右面斜线是累积完成价值项的数目。两条斜线的垂直距离表示某个时刻已经开始但还没有完成的价值项数目，也就是在制品的总计数量。两条斜线的水平间距表示价值项从开始到完成的周期时间，也就是从概念到交付的响应时间，它是价值流动效率的一个重要衡量。斜线的斜率反应的是价值交付的速率，也就是每周可以交付的价值项数量。</p>
<p><img src="https://static001.infoq.cn/resource/image/54/01/5414c088c5c0225968b9ca5b877cfa01.png"></p>
<p>累积流量是一个综合的价值流度量方法，可以通过它得到不同维度的信息。例如，我们设想限制在制品的数目，可以缩短周期时间、而对交付速率影响有限。但实际效果如何还要通过事实来检验，通过实验和度量，图中的数据基本验证了这一假设，让改进更有方向，结果更可衡量。同样的数据有不同的呈现方式，图 ㈩基于相同的数据，它突出了在制品数目和周期时间的变化趋势，以及两者的关系。从图中可以看出，周期时间的降低略滞后于在制品数量的降低，这符合精益理论，因为只有在积累的队列被处理完后，对交付周期的改进才能够显现出来。而图 11 反应的是系统流量（每周交付价值的数量）的变化趋势，为改进提供了信心。</p>
<h3 id="协同改进"><a href="#协同改进" class="headerlink" title="协同改进"></a>协同改进</h3><p>应用可视化、限制在制品数量、以及价值流度量，能够暴露产品开发中的问题和瓶颈。但发现问题还不够，重要的是如何去解决它们，对此看板开发方法给出了两个建议——团队协作和应用科学方法和模型。限制在制品数目本身就能够激发协作，例如在前面图 ㈧的看板墙，可能会出现以下的顺序场景</p>
<ol>
<li><p>测试遇到问题 (如输入质量太差) 而被阻塞 ，在制品数量达到上限</p>
</li>
<li><p>因在制品数量达到上限，根据规则，测试不能从上游（实现）拉入更多的工作</p>
</li>
<li><p>实现阶段已完成的工作无法进入下游测试环节，实现阶段的在制品数量很快也达到上限</p>
</li>
<li><p>实现要想开始更多的工作，就必须关注下游的问题，并做出反应，如提高本环节的输出质量，或者是给予帮助</p>
</li>
<li><p>实现和测试的协作使价值流动更加顺畅</p>
</li>
</ol>
<p><img src="https://static001.infoq.cn/resource/image/d4/47/d44efe50020a858d032e7d64fe427947.png"></p>
<p>图是”kanban – Successful Evolutionary Change for Your Technology Business”一书的封面插图，它反映了发生在看板墙前面的协同改进。看板开发方法的基本假设是：产品开发的目标不是单个环节效率的最大化，而是端到端价值流的提升。看板通过拉动机制暴露了限制价值流动的瓶颈，并激发团队协作，改善价值流动。</p>
<p>解决瓶颈问题的方案可能在瓶颈处，如临时加班、分配更多资源、或相邻环节的支持等。但很多时候解决瓶颈问题的方案在别处，例如提高瓶颈之前环节的输出质量，调整职责分配，甚至是重新设计工作流。</p>
<p>对于偶然出现的问题，只需要临时性解决方案。如突发性高负荷，可以通过暂时的相互支持解决。而对于系统性问题，如持续的负荷不均衡，则需要长期的方案和更加系统和科学的模型指导，如系统思考、精益思想、排队理论等，这些模型本身不属于看板方法的一部分，但它们让长期的改进有章可循，以后的文章，我将中深入地探讨其中的一些模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看板的实施正是从组织流程现状出发，首先可视化实际工作流并显式化流程；在此基础上，限制在制品数量形成拉动系统以暴露系统问题和瓶颈，度量价值流动以发现改进机会；并通过团队的协作，不断改进和演化出合适的流程、方法，实现一个高效、顺畅的产品开发价值流。</p>
<p>适应组织的具体情况，和发现合适的变革路径，这两点是敏捷实施的最大困难，看板给出了被证明可行的方案。这可能是看板能够在国外社区迅速推广并成功运用的原因，而在国内，看板这方面的价值还远未被认识和发掘。</p>
<p><a href="https://www.infoq.cn/article/kanban-development-method">https://www.infoq.cn/article/kanban-development-method</a></p>
]]></content>
      <tags>
        <tag>软件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Map</title>
    <url>/2022/04/20/C++%20Map/</url>
    <content><![CDATA[<h1 id="C-std-map-用法与范例"><a href="#C-std-map-用法与范例" class="headerlink" title="C++ std::map 用法与范例"></a>C++ std::map 用法与范例</h1><p>C++map是一个关联式容器，把键和值联系起来，并用该键来执行查找元素、插入元素、删除元素等操作。<br>map是有排序的关联式容器，会根据元素对应的键来排序，而且key是唯一值。如果同样的key再insert，就会覆盖原本的value。<br>map的运作方式通常是红黑树，这样可以保证在O(log n)时间内完成查找、插入、删除等操作。<br>需要引入头文件<code>&lt;map&gt;</code></p>
<h2 id="map-常用功能"><a href="#map-常用功能" class="headerlink" title="map 常用功能"></a>map 常用功能</h2><ul>
<li>元素存取：operator[]：存取指定的[i]元素的资料</li>
<li>迭代器：<code>begin()</code>,<code>end()</code>,<code>rbegin()</code>,<code>rend()</code></li>
<li>容量：<code>empty()</code>,<code>size()</code>,<code>max_size()</code></li>
<li>修改器：<code>clear()</code>,<code>insert()</code>,<code>erase()</code>,<code>swap()</code></li>
<li>查找：<code>count()</code>,<code>find()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; studentMap;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">studentMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">studentMap[<span class="number">1</span>] = <span class="string">&quot;Tom&quot;</span>;<span class="comment">//如果存在则覆盖</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; studentMap = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;Jack&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">studentMap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>具体和其他STL容器相似。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象基础</title>
    <url>/2022/04/20/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文为Java学习笔记，主要来自于廖雪峰网站。</p>
<span id="more"></span>

<h2 id="1-Java的继承"><a href="#1-Java的继承" class="headerlink" title="1.Java的继承"></a>1.Java的继承</h2><p>继承就是子类继承父类的方法，多态就是同一个方法可以有多种不同的实现形式（通过调用函数的传参来加以区分）</p>
<p>继承：用关键字<code>extends</code>来实现。<code>class Student extends Person</code></p>
<ul>
<li><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段</p>
</li>
<li><p>任何一个类（除了Object）都会继承自某个类。</p>
</li>
<li><p>Java只允许一个class继承自一个类，因此一个类有且仅有一个父类（除了Object）</p>
</li>
<li><p>继承的子类无法访问父类的private字段或private方法。可以把private改为protected。用protected修饰的字段可以被子类访问。</p>
</li>
<li><ul>
<li><p>super关键字</p>
</li>
<li><p>表示父类（超类）。子类引用父类的字段时，可以用super.fieldName</p>
</li>
<li><p>在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会自动加上一句<code>super();</code>（无参数构造方法）。所以如果父类没有无参数的构造方法就会编译失败。也就是说子类不会继承父类的任何构造方法。</p>
</li>
<li><p>可以用<code>super(name,age);</code>来显式调用。</p>
</li>
</ul>
</li>
<li><ul>
<li><p>阻止继承</p>
</li>
<li><p>正常情况下，只要某个class没有用final修饰符，那么任何类都可以从该class继承。</p>
</li>
<li><p>从Java15开始，循序使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>
</li>
<li><p>例如：定义一个shape类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shapr</span> permits Rect,Circle,Triangle&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只允许指定的三个类名继承他，否则就会报错。防止继承被滥用。</p>
</li>
</ul>
</li>
<li><ul>
<li><p>向上转型</p>
</li>
<li><pre><code class="java">Person p = new Student();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</span><br><span class="line"></span><br><span class="line">* * 向下转型</span><br><span class="line"></span><br><span class="line">  * ```java </span><br><span class="line">    Person p1 = new Student();</span><br><span class="line">    Student s1 = (Student) p1;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>但如果实际类型就是Person，就会转型失败，报错<code>ClassCastException</code>。</p>
</li>
<li><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果引用变量为null，那么总为false。</p>
</li>
<li><p>从Java14之后，判断instanceof后直接转型为指定变量。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-Java的多态"><a href="#2-Java的多态" class="headerlink" title="2.Java的多态"></a>2.Java的多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，称为覆写（Override）；如果方法签名不同，就是Overload。</p>
<ul>
<li>加上@Override可以帮助编译器检查是否进行了正确的Override。如果不小心写错了方法签名，编译器会报错。（但不是必须的）</li>
<li>一个实际类型为Student，引用类型为Person的变量，调用其run()方法（被子类Override），那么调用的时Person的还是Student的呢？</li>
<li>答案时Student的。因此可以得出结论，Java的实例方法调用时基于运行时的实际类型的动态调用，而非变量的声明类型。这个非常重要的特性在面向对象编程中称之为多态（Polymorphic）</li>
</ul>
<p>多态是指，针对某个类型的方法调用，真正执行的方法取决于运行实际实际类型的方法。</p>
<ul>
<li><p>加入编写这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">	p.run();</span><br><span class="line">	p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它传入的参数类型时Person，我们无法知道传入的实际参数究竟是Person还是Student还是其他子类，因此也就无法确定调用的是不是Person类定义的run()方法。</p>
</li>
<li><p>Polymorphism的优点，就是允许添加更多类型的子类实现功能扩展，却不需要秀给基于父类的代码。</p>
</li>
<li><ul>
<li>弊端：Fu f &#x3D; new Zi() f不能用子类特有方法</li>
<li>解决方法：Zi z &#x3D; (Zi)f 由于本身是子类对象，可以向下转型成子类引用，再调用子类特有方法。</li>
</ul>
</li>
</ul>
<h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><h3 id="抽象类的定义"><a href="#抽象类的定义" class="headerlink" title="抽象类的定义"></a>抽象类的定义</h3><p>如果父类的方法本身不需要实现任何功能，仅仅时为了定义方法签名，目的是让子类去Override，那么，可以把父类的方法声明为抽象方法。</p>
<p>注意，有抽象方法的类必须声明为抽象类，这样才能正确编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类本身设计成只能用于被继承，无法被实例化，子类必须Override抽象方法。</p>
<h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类Person，以及具体的Student、Teacher子类之后，我们可以通过抽象类Person类型去引用具体的子类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure>

<p>这种引用抽象类的好处在于，我们对其进行方法的调用，并不关心Person类型变量的具体子类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure>

<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：<code>abstract class Person</code>)</li>
<li>不需要子类就可以实现业务逻辑（正常编译）</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心</li>
</ul>
<h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><p>A：抽象类和抽象方法必须用abstract关键字修饰。</p>
<p>​    B：抽象类中不一定有抽象方法，但是有抽象方法的累必须定义为抽象类</p>
<p>​    C：抽象类不能被实例化，因为它不是具体的。</p>
<p>​            抽象类有构造方法，但是不能实例化？构造方法的作用是什么呢？</p>
<p>​            答：用于子类访问父类数据的初始化</p>
<p>​    D：抽象的子类</p>
<p>​            a.如果不想重写抽象方法，该子类是一个抽象类。</p>
<p>​            b.重写所有抽象方法，这时候子类是一个具体的类。</p>
<p>​    抽象类的实例化其实是靠具体的子类实现的，是多态的方式。</p>
<p>​    Animal a &#x3D; new Cat();</p>
<p>多态其实主要用于抽象类和其具体子类，而不是具体类和具体类之间。</p>
<h3 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h3><p>A：成员区别</p>
<p>​        抽象类：成员变量：可以变量，可以常量</p>
<p>​        构造方法：有</p>
<p>​        成员方法：可以抽象，也可以非抽象</p>
<p>B：关系区别</p>
<p>​        类与类：继承，单继承</p>
<p>​        类与接口：实现，单实现，多实现</p>
<p>​        接口与接口：继承，单继承，多继承</p>
<p>C：设计理念区别：</p>
<p>​        抽象类：被继承体现的是“is a”的关系，抽象类中定义的是该继承体系的共性功能。</p>
<p>​        接口：被实现体现的是“like a”的关系，接口中定义的是该继承体系的扩展功能。</p>
<h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h2><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">	String getName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来。</p>
<p>当一个具体的class去实现interface时，需要使用implements关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个interface可以继承自另一个interface，使用<code>extends</code>关键字，相当于扩展了接口的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象。</p>
<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>可以在接口中定义default方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类可以不必Override default方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h2 id="5-静态字段和静态方法"><a href="#5-静态字段和静态方法" class="headerlink" title="5.静态字段和静态方法"></a>5.静态字段和静态方法</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p>
<p>还有一种字段，是用<code>static</code>修饰的字段，成静态字段<code>static field</code>，每个实例都会共享该字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐使用<code>实例变量.静态字段</code>去访问静态字段，推荐使用<code>类名.静态字段</code>来访问。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>用static修饰的方法称为静态方法。</p>
<p>调用静态方法不需要实例变量，通过类名就可以调用。静态方法属于class而不属于实例，因此，静态方法内部无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p>
<p>静态方法常用于工具类。例如：</p>
<ul>
<li>Arrays.sort()</li>
<li>Math.random()</li>
</ul>
<p>静态方法也常用于辅助方法。注意到main方法也是静态方法。</p>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p>interface中可以有静态字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中public static final也可以省略，编译器会自动加上。</p>
<h2 id="6-包（Package）"><a href="#6-包（Package）" class="headerlink" title="6.包（Package）"></a>6.包（Package）</h2><p>在现实中，如果两个人写了相同的类名，或者自己写的类名和JDK的类名相同，如何解决类名冲突？</p>
<p>在Java中，我们使用package来解决名字冲突。</p>
<p>Java定义了一种名字空间，成之类包（package），一个类总是属于某个包。类名（比如Person）只是一个简写，真正的完整类名是<code>包名.类名</code></p>
<p>例如：</p>
<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>
<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>
<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>
<p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>
<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>
<p>小明的<code>Person.java</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ming; // 申明包名ming</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小军的<code>Arrays.java</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package mr.jun; // 申明包名mr.jun</span><br><span class="line"></span><br><span class="line">public class Arrays &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>
<p><strong> 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</strong></p>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure>

<p>即所有Java文件对应的目录层次要和包的层次一致。</p>
<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>

<p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure>

<p>在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。</p>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，每次写完整类名比较痛苦。</p>
<p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>import static</code>很少使用。</p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.Format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.List list; <span class="comment">// ok，使用完整类名 -&gt; java.util.List</span></span><br><span class="line">        <span class="type">Format</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ok，使用import的类 -&gt; java.text.Format</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>; <span class="comment">// ok，使用java.lang包的String -&gt; java.lang.String</span></span><br><span class="line">        System.out.println(s); <span class="comment">// ok，使用java.lang包的System -&gt; java.lang.System</span></span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li>默认自动<code>import java.lang.*</code>。</li>
</ul>
<p> 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
<p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和<code>java.lang</code>包的类重名，也不要和JDK常用类重名。</p>
<h2 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7.作用域"></a>7.作用域</h2><p>public：可以被其他任何类访问</p>
<p>private：访问权限限定在class的内部。由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有private的权限。</p>
<p>protected：可以被子类，子类的子类等访问</p>
<p>package</p>
<p>局部变量</p>
<p>final：与访问权限不冲突。作用：1.修饰class阻止被继承。2.修饰method阻止被子类覆写。3.修饰field阻止被重新赋值。4.修饰局部变量阻止被重新赋值。</p>
<h2 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8.内部类"></a>8.内部类</h2><p>有一种类，它被定义在另一个类的内部，所以成为内部类（Nested Class）。Java内部类分为好几种，通常情况下用的不多。</p>
<h3 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h3><p>如果一个类定义在另一个类内部，这个类就是Inner Class：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p>
<p>Inner Class可以修改Outer Class的private字段，访问private方法。</p>
<h3 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h3><p>还有一种定义Inner Class的方法，不需要在Outer Class中明确定义Class，而是在方法内部，通过匿名类（Anonymous Class）来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>观察asyncHello()方法，我们在方法内部实例化了一个Runnable。Runnable本身是接口，接口是不能被实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">	<span class="comment">//实现必要的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p>
<p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，并且添加了<code>static</code>代码块来初始化数据。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p>
<h3 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h3><p>和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<h2 id="9-classpath和jar"><a href="#9-classpath和jar" class="headerlink" title="9.classpath和jar"></a>9.classpath和jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p>classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class，即如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。</p>
<p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>或者使用<code>-cp</code>的简写。如果没有设置则默认为当前目录<code>.</code>。</p>
<p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\work</code>，那么，目录结构必须如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work</span><br><span class="line">└─ com</span><br><span class="line">   └─ example</span><br><span class="line">      └─ Hello.class</span><br></pre></td></tr></table></figure>

<p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work&gt; java -cp . com.example.Hello</span><br></pre></td></tr></table></figure>

<p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>
<p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<h2 id="10-模块"><a href="#10-模块" class="headerlink" title="10.模块"></a>10.模块</h2><p>jar只是用于存放class的容器，它并不关心class之间的依赖。</p>
<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p>
<p>打包模块和JRE（略）</p>
<h2 id="11-为什么new子类要先执行父类的构造方法"><a href="#11-为什么new子类要先执行父类的构造方法" class="headerlink" title="11.为什么new子类要先执行父类的构造方法"></a>11.为什么new子类要先执行父类的构造方法</h2><p>实例化的本质，是调用构造函数分配实例标识，申请内存存放实例中各成员变量的初始值。如果该类继承了某个父类，也就继承了（相当于复制）了父类的所有非私有成员变量，而入伏哦没有给继承过来的成员变量赋初值，那后续施加在该成员变量的操作便无法进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">p_StaticField</span> <span class="operator">=</span> <span class="string">&quot;父类--静态变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 变量(其实这用对象更好能体同这一点，如专门写一个类的实例)</span></span><br><span class="line">　　</span><br><span class="line">    <span class="comment">//如果这个变量放在初始化块的后面，是会报错的，因为你根本没有被初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">p_Field</span> <span class="operator">=</span> <span class="string">&quot;父类--变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(p_StaticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p_Field);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类--构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s_StaticField</span> <span class="operator">=</span> <span class="string">&quot;子类--静态变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">s_Field</span> <span class="operator">=</span> <span class="string">&quot;子类--变量&quot;</span>;</span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s_StaticField);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类--静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s_Field);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类--初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类--构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 程序入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************in main***************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************second subClass***************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subClass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>对象与this</title>
    <url>/2022/04/20/%E5%AF%B9%E8%B1%A1%E4%B8%8Ethis/</url>
    <content><![CDATA[<h2 id="self与this"><a href="#self与this" class="headerlink" title="self与this"></a>self与this</h2><p>对象，可以理解为“多个相关数据的统一载体”。比如一个人，有name，age，height等社会或生理体征，而这些数据是数以一个个体的，如果用数组去存，表现力有所欠缺，无法表达“它们属于同一个个体”的含义。</p>
<p>但我们知道，在Java中对象是在堆空间中生成的，数据会在堆空间占据一定的内存开销，而方法只有一份。</p>
<p>为什么方法被设计出只有一份呢？</p>
<p>因为多个个体，属性可能不同，但我们都有相同的method，没必要和属性数据一样在堆空间各存一份，所以被抽取出来存放。</p>
<p>此时，方法相当于一套指令模板，谁都可以传入数据交给它执行，然后得到执行后的结果返回。</p>
<p>那么，方法如何知道是谁执行的呢？</p>
<p>python的self，Java的this其实就是解决这个问题的。可以理解为对象内部持有一个应用，党调用某个方法时，必须传递这个对象引用，然后方法根据这个引用就知道当前这套指令是对哪个对象的数据进行操作了。</p>
<h2 id="static与this"><a href="#static与this" class="headerlink" title="static与this"></a>static与this</h2><p>我们都知道，static修饰的属性或方法其实是属于类的，是所有对象共享的。</p>
<p>之所以一个变量或者方法要声明为static，是因为</p>
<ul>
<li>static变量：大家共有的，大家都一样，不是特定的差异化数据</li>
<li>static方法：这个方法不处理差异化数据</li>
</ul>
<p>也就是说，static注定是与差异化数据无关，也就是与具体对象的数据无关。</p>
<p>以静态方法为例，当你确定一个方法只提供通用的操作流程，而不会在内部引用具体对象的数据时，你就<strong>可以</strong>把它定为静态方法。</p>
<p>这个其实和我们之前听到的解释不一样。网络上一贯的解释都是上来就告诉你静态方法不能访问实例变量，再解释为什么，是倒着解释的。而上面这段话的出发点是，当你满足什么条件时，你就可以把一个方法定为静态方法。</p>
<p>为什么Java中静态方法无法访问非静态数据（实例字段）和非静态方法（实例方法）。<strong>因为Java不会在调用静态方法时传递this，静态方法内没有this当然无法调用实例相关的一切。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们在一个实例方法中调用另一个实例方法或者实例变量时，其实都是通过<span class="built_in">this</span>调用的，比如</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，有些培训班视频会说静态方法随着类加载而加载，此时并没有对象实例化，所以静态方法无法访问实例相关数据，倒也勉强说得通。看大家自己怎么理解了，能自圆其说即可。</p>
<p>java子类实例化时会隐式调用父类构造器</p>
<p>本质和子类调用方法给父类传参一样一样的！只不过传参的过程很特殊：</p>
<ul>
<li>new的时候自动传参，不是我们主动调用，所以感知不到</li>
<li>Java中的this是隐式传递的，所以我们更加注意不到了</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索（DFS）</title>
    <url>/2022/04/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>深度优先搜索算法是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已大仙从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程。整个进程反复进行直到所有节点都被访问为止。</p>
<p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序表。利用拓扑排序表可以方便的解决很有相关的图论问题，如无权最长路径问题等等。</p>
<p>因发明“深度优先搜索算法”，约翰·霍普克罗夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.首先将根节点放入stack中。</p>
<p>2.从stack中取出第一个节点，并检验它是否为目标。</p>
<p>​            如果找到目标，则结束搜寻并回传结果。</p>
<p>​            否则将它某一个尚未检验过的直接子节点加入stack中。</p>
<p>3.重复步骤2.</p>
<p>4.如果不存在未检测过的直接子节点。</p>
<p>​            将上一级节点加入stack中。</p>
<p>​            重复步骤2.</p>
<p>5.重复步骤4。</p>
<p>6.如果stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p>
<h2 id="实现代码（略）"><a href="#实现代码（略）" class="headerlink" title="实现代码（略）"></a>实现代码（略）</h2><p>用for循环遍历某一步的所有可能，使用递归实现进入下一个节点，并修改状态。递归结束后恢复初始状态。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索（BFS）</title>
    <url>/2022/04/19/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>广度优先搜索算法是一种图形搜索算法。简单的说，BDFS是从根节点开始，沿着树的宽度遍历树的结点。如果所有节点均被访问，则算法终止。广度优先搜索一般用队列（Queue）实现。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>BFS是一种暴力搜索算法，目的是系统地展开并检查图红的所有节点，以寻找结果。换句话说，它并不考虑结果的可能地址，彻底地搜索整张图，知道找到结果为止。BFS并不使用经验法则算法。</p>
<p>从算法的观点，所有展开节点得到的子节点都会被加进一个先进先出的队列中，从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜索并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。如果队列为空，表示整张图都检查过了，即图中没有搜索的目标，那么就结束搜索并回传“找不到目标”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::queue&lt;node *&gt; visited, unvisited;</span><br><span class="line">node nodes[<span class="number">9</span>];</span><br><span class="line">node *current;</span><br><span class="line"></span><br><span class="line">unvisited.<span class="built_in">push</span>(&amp;nodes[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!unvisited.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">    current = (unvisited.<span class="built_in">front</span>()); <span class="comment">// 目前的应该检验的</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        unvisited.<span class="built_in">push</span>(current-&gt;left); </span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) </span><br><span class="line">        unvisited.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    visited.<span class="built_in">push</span>(current);</span><br><span class="line">    cout &lt;&lt; current-&gt;self &lt;&lt; endl;</span><br><span class="line">    unvisited.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索算法的应用"><a href="#广度优先搜索算法的应用" class="headerlink" title="广度优先搜索算法的应用"></a>广度优先搜索算法的应用</h2><p>广度优先搜索能用来解决图论中的许多问题，例如：</p>
<ul>
<li>查找图中的所有连接组件（Connected Component）。一个连接组件是图中的最大相连子图。</li>
<li>查找连接组件中的所有节点。</li>
<li>查找非加权图中任两点的最短路径</li>
<li>测试一个图是否为二分图</li>
<li>（Reverse）Cuthill-McKee算法</li>
</ul>
<h3 id="查找连接组件"><a href="#查找连接组件" class="headerlink" title="查找连接组件"></a>查找连接组件</h3><p>从起点开始，执行DFS后经过的所有节点，即包含起点的一个连接组件。</p>
<h3 id="测试是否为二分图"><a href="#测试是否为二分图" class="headerlink" title="测试是否为二分图"></a>测试是否为二分图</h3><p>从任意结点开始搜索，并在搜索过程中给节点不同的标签。例如，给开始节点标签0，开始节点所有邻居标签1，开始节点所有邻居的邻居标签0……以此类推。若在此搜索过程中，任一节点有跟其相同标签的邻居，则此图就不是二分图，否则是二分图。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>元学习（乱）</title>
    <url>/2022/04/18/%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%B1%EF%BC%89/</url>
    <content><![CDATA[<p>传统的机器学习-&gt;需要大量的数据-&gt;但是元学习即使是少量的数据也能达到相同的（compatible）效果。</p>
<p>样本过少可能产生过拟合-&gt;应用转移学习，先用充足的common classes训练</p>
<p>N-way and K-shot: N classes, K support samples and Q query samples</p>
<p>The goal: classify these N x Q query samples into N classes based on the N x K support samples.</p>
<p>元学习（meta-learning）在某些地方不如全分类（whole-classification）</p>
<p>Classifier-Baseline</p>
<p>Meta-Baseline</p>
<p> inheriting one of the most effective evaluation metrics of the whole-classification model</p>
<p>meta-learning 的框架可以分成三类：1.Memory-based methods 2.Optimization-based methods 3.metric-based methods</p>
<p>该文章主要的内容：探讨whole-classification 和 meta-learning objectives的区别。</p>
<p>传统的few-shot classification是给大容量的base数据集，然后用少量样本训练出新的数据集。在N-way K-shot few shot classification中，support-set有N classes with K samples per class，the query-set 在n类每类中有Q samples，目标就是分类N x Q query images into N classes。</p>
<p>做了个实验。。。</p>
<p>很多其他的方法都需要更多的参数，更加复杂的设计，而meta-baseline更加简单。</p>
<p>meta-baseline和classifier-baseline之前的差异很小。</p>
<p>base class generation上升，novel class generation在下降。让base更好的时候的副作用。</p>
<p>meta-baseline trained without classification training stage 在base class generalization方面更好，但是在novel class generalization上meta-baseline with whole-classification training 更好。也就是说whole-classification提供了更强的转移能力，有助于在新的分类上产生更好的效果。但也有trade-off发生在base class上。</p>
]]></content>
  </entry>
  <entry>
    <title>Lifelong Learning简介</title>
    <url>/2022/04/18/Lifelong-Learning%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="2020机器学习前沿技术—-LifeLong-learning"><a href="#2020机器学习前沿技术—-LifeLong-learning" class="headerlink" title="2020机器学习前沿技术—-LifeLong learning"></a>2020机器学习前沿技术—-LifeLong learning</h1><h2 id="1-为什么要研究LifeLong-learning"><a href="#1-为什么要研究LifeLong-learning" class="headerlink" title="1.为什么要研究LifeLong learning"></a>1.为什么要研究LifeLong learning</h2><p>细数机器学习处理的问题，概括地讲，可以分为如下几类：</p>
<ul>
<li>计算机视觉（CV）： object classification, object detection, object segmentation, style transfer, denoising, image generation, image caption</li>
<li>语音（Speech) : speech recogniton， speech synthesis</li>
<li>自然语言处理（NLP): Machine translation, text classfication， emotional recogniton</li>
<li>推荐系统: Recommendation, CRT</li>
</ul>
<p>目前针对各个大类的不同子问题，都会设计不同的网络结构，设计不同的loss，采用不同的数据据处理。这使得机器学习”偏科严重“。</p>
<h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><p>LifeLong learning意味着以前学到的知识，能够促进下一个任务Task B的学习，在学习完Task B之后，要不仅可以很好地处理Task B，同时在Task A上不能有明显的下降，最好是有所提升或者保持。</p>
<p>学完Task A再学Task B，Task A的准确率就会下降很多，这就是Forget，这就是Transfer Learning所带来的问题，也是LifeLong learning需要解决的问题。</p>
<p>如果采用Multi-task Learning，需要把Task A 和Task B的训练数据都存储起来，需要的时候放在一起训练。虽然Task A和B都达到了不错的效果，但是所有数据的存储会是一个很大的问题。</p>
<p>因此，如何解决数据存储的问题呢？可以借助于GAN网络来完成，减少了数据存储，但带来了更大的计算量。</p>
<h2 id="3-这个领域还有那些前沿的研究方向"><a href="#3-这个领域还有那些前沿的研究方向" class="headerlink" title="3.这个领域还有那些前沿的研究方向"></a>3.这个领域还有那些前沿的研究方向</h2><ul>
<li><p><strong>Curriculum Learning</strong> 类似于一个课程系的学习， 研究的是如何安排课程学习的先后顺序。</p>
</li>
<li><p><strong>Taskonomy</strong> 研究的是各个任务之间的关系， 即该先学哪个，后学哪个。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>prompt简介</title>
    <url>/2022/04/18/prompt%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>近年来，NLP技术发展迅猛。自BERT于2018年被提出以来，“pre-train+fine-tune”便成为了席卷整个NLP领域的学习范式。然而，自GPT-3开始，一种新的范式引起了大家的关注并越来越流行：prompt-based learning。<br>prompt-learning生成插槽，对下游任务进行重构，然后进行answer search、answer mapping，对[Z]槽位进行预测，选取得分最高的token z 作为输出即可，然后将z映射为最终输出y。<br>相比“pre-train+fine-tune”的范式，“prompt-based learning”有什么显著的优势？</p>
<ul>
<li><p>从应用场景看，可以解决zero-shot问题</p>
</li>
<li><p>从使用成本来看，由于后者可以不对pre-trained LM做fine-tune，因此使用起来成本更低。</p>
</li>
</ul>
<p>prompt-based learning，给了我们什么样的启示？</p>
<ul>
<li>pre-train是必要的，但，fine-tune未必。换言之，fine-tune或许不是利用pre-trained LM 的唯一方式，更不是最有效的方式。</li>
</ul>
<p>如果包含了额外的prompt params，那么这种形式的“primpt-based learning”和”pre-train+fine-tune”的范式有什么区别？</p>
<ul>
<li>表象上来看，他俩确实区别不大，无非是起到“Adapter”作用的参数所处的位置不同。但是本质上，它们是完全不同的。前者的参数是为了让下游任务向预训练模型适配，后者的参数是为了让预训练模型向下游任务适配，这不同的出发点很可能导致了训练难度的不同，继而导致最终的效果不同。</li>
</ul>
]]></content>
      <tags>
        <tag>Machine Learining</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常见套路</title>
    <url>/2022/04/15/git-%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>本文介绍git常见操作，仅仅设计四个命令：<code>add</code>，<code>commit</code>，<code>reset</code>，<code>checkout</code>.</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行git操作前，一定要明白git的三个【分区】是什么，否则的话肯定没办法真正理解Git的原理。</p>
<p>Git的三个分区分别是：<code>working directory</code> ，<code>stage/index area</code> ，<code>commit history</code>。</p>
<p>working directory是工作目录，也就是我们肉眼能看到的文件。在执行git add相关相关命令后，就会把work dir中的修改添加到暂存区stage area（或者叫index area）中。</p>
<p>当stage中存在修改时，我们使用git commit相关命令之后，就会把stage中的额修改保存到提交历史中，也就是HEAD指针指向的位置。</p>
<p>任何修改只要进入commit history，基本可以认为永远不会丢失了。每个commit都有唯一的hash值，我们经常说的HEAD或者master分支，都可以理解为一个只想某个commit的指针。</p>
<p>work dir和stage区域的状态，可以通过命令git status来查看，history区域的提交历史可以通过git log来查看。</p>
<h2 id="本地Git极简教程"><a href="#本地Git极简教程" class="headerlink" title="本地Git极简教程"></a>本地Git极简教程</h2><h3 id="需求一，如何把work-dir中的修改加入stage。"><a href="#需求一，如何把work-dir中的修改加入stage。" class="headerlink" title="需求一，如何把work dir中的修改加入stage。"></a>需求一，如何把work dir中的修改加入stage。</h3><p>使用git add相关命令就行了。顺便一提，add有个别名叫做stage，也就是git stage和git add命令是完全一样的。</p>
<h3 id="需求二，如何把stage中的修改还原到work-dir中。"><a href="#需求二，如何把stage中的修改还原到work-dir中。" class="headerlink" title="需求二，如何把stage中的修改还原到work dir中。"></a>需求二，如何把stage中的修改还原到work dir中。</h3><p>使用checkout命令，比如修改了a.txt，现在想要还原成原来的文件，使用<code>git checkout a.txt</code> ，那么就能还原成stage中的状态。</p>
<p>如果需要还原全部文件，可以用点（.）通配符。</p>
<p>work dir中的修改会被stage覆盖，无法恢复，所以使用该命令是需要确定work dir中的修改可以抛弃。</p>
<h3 id="需求三，将stage区的文件添加到history区。"><a href="#需求三，将stage区的文件添加到history区。" class="headerlink" title="需求三，将stage区的文件添加到history区。"></a>需求三，将stage区的文件添加到history区。</h3><p>使用<code>git commmit -m ‘一些描述’</code></p>
<p>如果commit完之后，发现一些错别字需要修改，又不想为改几个错别字而新开一个commit到history区，那么可以用 <code>git commit --amend</code> 这样就是把错别字的修改和之前的哪个commit中的修改合并，作为一个commit提交到history区。</p>
<h3 id="需求四，将history区的文件还原到stage区。"><a href="#需求四，将history区的文件还原到stage区。" class="headerlink" title="需求四，将history区的文件还原到stage区。"></a>需求四，将history区的文件还原到stage区。</h3><p>如果修改了一个文件，使用了git add . ，然后发现这个文件还需要求改，不想commit，想从stage中撤销，那么可以使用<code>git reset</code>命令：<code>git reset a.txt</code></p>
<p>这样就可以把a.txt文件从stage区移除，这时候进行commit操作就不会一起提交到history区了。上面的这个命令是一个简写，实际上reset命令的完整写法如下： <code>git reset --mixed HEAD a.txt</code> ，其中，mixed是一个模式（mode）参数，如果reset省略这个选项的话默认是mixed模式，HEAD指定了一个历史提交的hash值，a.txt指定了一个文件或者多个文件。</p>
<p>该命令的自然语言描述是：不改变work dir中的任何数据，将stage区域中的a.txt文件还原成HEAD指向的commit history中的样子。就相当于把对a.txt的修改从stage区撤销，但依然保存在work dir中，变为unstage的状态。</p>
<p>不会改变work dir中的数据，会改变stage区的数据，所以应确保stage中被改动的数据是可以抛弃的。</p>
<h3 id="需求五，将work-dir的修改提交到history区。"><a href="#需求五，将work-dir的修改提交到history区。" class="headerlink" title="需求五，将work dir的修改提交到history区。"></a>需求五，将work dir的修改提交到history区。</h3><p>先git add 然后 git commit就行了，或者一个快捷方法是使用命令 git commit -a。</p>
<h3 id="需求六，将history区里的历史提交还原到work-dir中。"><a href="#需求六，将history区里的历史提交还原到work-dir中。" class="headerlink" title="需求六，将history区里的历史提交还原到work dir中。"></a>需求六，将history区里的历史提交还原到work dir中。</h3><p>依然是使用checkout命令，但和之前的使用方式有一些不同：</p>
<p><code>git checkout HEAD .</code></p>
<p>这样，work dir 和stage中的所有修改都会被撤销，恢复成HEAD指向的哪个history commit。</p>
<p>注意，这里撤销的也只是修改，新增的文件不会被撤销。</p>
<p>当然，只要找到任意一个commit的HASH值，checkout命令就可以将文件恢复成任一个history commit中的样子。</p>
<p><code>git checkout 2bdf04a some_test.go</code></p>
<p>这个操作会将指定文件在work dir的数据恢复成commit的样子，且会删除该文件在stage中的数据，都无法恢复。</p>
<h2 id="三、其他技巧"><a href="#三、其他技巧" class="headerlink" title="三、其他技巧"></a>三、其他技巧</h2><h3 id="需求一，合并多个commit"><a href="#需求一，合并多个commit" class="headerlink" title="需求一，合并多个commit"></a>需求一，合并多个commit</h3><p>比如说我本地从17bd20c到HEAD有多个commit，但我希望把他们合并成一个commit推到远程仓库，这时候就可以使用reset命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset 17bd20c</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>相当于把HEAD已到了17bd20c这个commit，而且不会修改work dir中的数据，只要add再commit，就相当于把中间的多个commit合并到一个了。</p>
<h3 id="需求二，由于HEAD指针的回退，导致有的commit在git-log命令中无法看到，怎么得到它们的Hash值呢？"><a href="#需求二，由于HEAD指针的回退，导致有的commit在git-log命令中无法看到，怎么得到它们的Hash值呢？" class="headerlink" title="需求二，由于HEAD指针的回退，导致有的commit在git log命令中无法看到，怎么得到它们的Hash值呢？"></a>需求二，由于HEAD指针的回退，导致有的commit在git log命令中无法看到，怎么得到它们的Hash值呢？</h3><p>只要不乱动本地的.git文件夹，任何修改只要提交到commit history中，都永远不会丢失。看不到某些commit只是因为他们不是我们当前HEAD位置的历史提交，我们能可以使用如下命令查看操作记录：</p>
<p><code>git reflog</code></p>
<p>比如reset，checkout等等关键操作都会在这里留下记录，所有commit的Hash值都能在这里找到。</p>
<h3 id="需求三，怎么解决冲突"><a href="#需求三，怎么解决冲突" class="headerlink" title="需求三，怎么解决冲突"></a>需求三，怎么解决冲突</h3><p>比较流行的代码编辑器或者IDE都会集成方便的可视化Git工具，至于解决冲突，可视化的表现方式比在命令行里git diff清晰多了。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常见套路</title>
    <url>/2022/04/15/git%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="git更新本地代码"><a href="#git更新本地代码" class="headerlink" title="git更新本地代码"></a>git更新本地代码</h1><h2 id="1-本地代码未修改，只有master分支，直接更新"><a href="#1-本地代码未修改，只有master分支，直接更新" class="headerlink" title="1.本地代码未修改，只有master分支，直接更新"></a>1.本地代码未修改，只有master分支，直接更新</h2><p>git pull</p>
<p>前提是本地的代码没更改过。比如，你提交了代码到github后，随后别人也提交代码到github，然后你需要更新别人提交的代码到你本地，就可以直接使用该命令。假如你提交代码后再修改过本地的代码，就会产生冲突，直接使用该命令会失败。</p>
<h2 id="2-本地代码有修改，多分支。"><a href="#2-本地代码有修改，多分支。" class="headerlink" title="2.本地代码有修改，多分支。"></a>2.本地代码有修改，多分支。</h2><p>&#x2F;&#x2F;切换到master分支</p>
<p>git checkout master</p>
<p>&#x2F;&#x2F;更新master分支</p>
<p>git pull</p>
<p>&#x2F;&#x2F;切换到自己的分支isso</p>
<p>git checkout isso</p>
<p>&#x2F;&#x2F;把master分支合并到自己分支</p>
<p>git merge master</p>
<h2 id="3-本地代码有修改，只有master分支，直接覆盖本地代码。"><a href="#3-本地代码有修改，只有master分支，直接覆盖本地代码。" class="headerlink" title="3.本地代码有修改，只有master分支，直接覆盖本地代码。"></a>3.本地代码有修改，只有master分支，直接覆盖本地代码。</h2><p>&#x2F;&#x2F;重置索引和工作目录</p>
<p>git reset –hard</p>
<p>&#x2F;&#x2F;更新代码</p>
<p>git pull</p>
<h2 id="4-本地代码有修改，直接覆盖远程仓库代码"><a href="#4-本地代码有修改，直接覆盖远程仓库代码" class="headerlink" title="4.本地代码有修改，直接覆盖远程仓库代码"></a>4.本地代码有修改，直接覆盖远程仓库代码</h2><p>&#x2F;&#x2F;覆盖isso分支</p>
<p>git push –force origin isso</p>
<p>&#x2F;&#x2F;覆盖主分支</p>
<p>git push –force origin master</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ unordered_set</title>
    <url>/2022/04/14/C++unordered-set/</url>
    <content><![CDATA[<h1 id="C-std-unordered-set用法与范例"><a href="#C-std-unordered-set用法与范例" class="headerlink" title="C++ std::unordered_set用法与范例"></a>C++ std::unordered_set用法与范例</h1><p>unordered_set是一种关联式容器，里面的元素是唯一的，并且是无排序容器，里面的值不可修改，但是可以插入或删除元素。</p>
<p>unordered_set和set不同之处是：set是红黑树操作，红黑树具有排序功能。unordered_set是哈希表（hash table）操作的，插入和查询的时间复杂度很低，为常数级别，相对代价是消耗较多的空间，无自动排序功能。</p>
<p>需要引入头文件：<code>#include&lt;unordered_set&gt;</code></p>
<h2 id="unordered-set-初始化用法"><a href="#unordered-set-初始化用法" class="headerlink" title="unordered_set 初始化用法"></a>unordered_set 初始化用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; myyunordered_set&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>从c-style阵列来初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">myunordered_set</span>(arr,arr+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="unordered-set插入元素"><a href="#unordered-set插入元素" class="headerlink" title="unordered_set插入元素"></a>unordered_set插入元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="遍历unordered-sort容器"><a href="#遍历unordered-sort容器" class="headerlink" title="遍历unordered_sort容器"></a>遍历unordered_sort容器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s : myunordered_set)&#123;</span><br><span class="line">	std::cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用迭代器的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::unordered_set&lt;<span class="type">int</span>&gt;::iterator it = myunordered_set.<span class="built_in">begin</span>(); it != myunordered_set.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-set删除指定元素"><a href="#unordered-set删除指定元素" class="headerlink" title="unordered_set删除指定元素"></a>unordered_set删除指定元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如果删除了不存在的元素，上述代码返回值为0；否则返回值为1。</p>
<h2 id="清空unordered-set元素"><a href="#清空unordered-set元素" class="headerlink" title="清空unordered_set元素"></a>清空unordered_set元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<h2 id="判断unordered-set中元素是否存在"><a href="#判断unordered-set中元素是否存在" class="headerlink" title="判断unordered_set中元素是否存在"></a>判断unordered_set中元素是否存在</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">count</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="判断unordered-set是否为空"><a href="#判断unordered-set是否为空" class="headerlink" title="判断unordered_set是否为空"></a>判断unordered_set是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myunordered_set.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ Set</title>
    <url>/2022/04/14/C++Set/</url>
    <content><![CDATA[<h1 id="C-std-set用法与范例"><a href="#C-std-set用法与范例" class="headerlink" title="C++ std::set用法与范例"></a>C++ std::set用法与范例</h1><p>set是一个关联式容器，里面的元素是唯一的，而且是有排序的容器。set容器里面的元素的值是不可修改的，但set容器可以插入或删除元素。set通常是用红黑树（red-black tree）操作的。</p>
<p>要使用set容器，需要引入头文件<code>&lt;set&gt;</code></p>
<span id="more"></span>

<p>c++初始化用法：</p>
<p><code>std::set&lt;int&gt; myset&#123;1,2,3,4,5&#125;;</code></p>
<p>从c-style阵列来初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">std::set&lt;<span class="type">int</span>&gt; <span class="title">mytest</span><span class="params">(arr,arr+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>set中插入元素：</p>
<p><code>myset.insert(1)</code></p>
<p>由于set容器中没有at()成员函数，也没有operator[]，set无法单纯地随机读取某元素。但能通过iterator来读取元素。</p>
<p>下面先介绍使用range-based for loop来遍历set容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std-set.cpp<span class="comment">// g++ std-set.cpp -o a.out -std=c++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; myset = &#123;<span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;s : myset) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：1 2 3 4 5</p>
<p>由此可见元素是从小到大排序的，所以set容器在插入元素的同时会根据元素来进行排序，并且没有元素重复。</p>
<p>也可以使用迭代器的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = myset.<span class="built_in">begin</span>(); it != myset.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// for (auto it = myset.begin(); it != myset.end(); it++) &#123;</span></span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>（如果用rbegin()和rend()，就是反向迭代器，从大到小输出）</p>
<p>set中删除指定元素：<code>erase()</code></p>
<p><code>myset.erase(2);</code></p>
<p>这个函数有返回值，即是删除的元素的个数。如果要删除的元素在set中不存在，那么返回值就是0，并不会产生错误。</p>
<p>set中清空容器：<code>clear()</code></p>
<p><code>myset.clear()</code></p>
<p>set中判断元素是否存在：</p>
<p>第一种方法是用<code>count()</code>成员函数，如果存在则返回1，不存在则返回0。</p>
<p>第二种方法是使用<code>find()</code>成员函数，如果又找到就返回该特定元素的iterator，否则返回<a href="https://en.cppreference.com/w/cpp/container/set/end">past-the-end(end()) iterator</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; myset = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> search = myset.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (search != myset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; *search &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// Found 2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>set中判断容器是否为空：<code>empty()</code></p>
<p>返回值布尔类型</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>计网实验（网络版）</title>
    <url>/2022/04/14/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%EF%BC%88%E7%BD%91%E7%BB%9C%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="计网实验（网络版）"><a href="#计网实验（网络版）" class="headerlink" title="计网实验（网络版）"></a>计网实验（网络版）</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>1）打开packet tracer，在里面新建路由器（routers）和pc（End Devices），用console线（蓝色）连接路由器console口和pc的串口（com1,i.e. RS232)，即可完成连接。</p>
<p>2）双击pc，打开terminal，波特率选择9600，其余默认，然后就能进入用户模式。</p>
<p>3）用户模式：router&gt;</p>
<p>​      特权模式：router#</p>
<p>​      全局配置模式：router(config)#</p>
<p>要进入特权模式，输入enable；要进入全局配置模式，在特权模式下输入configure terminal；在全局配置模式中可以选择端口；按Ctrl+Z可以退出全局配置模式。</p>
<p>4）编辑路由器登陆信息：</p>
<p>Router(config)#banner motd “Welcomee to NJU”</p>
<p>5）配置端口描述：</p>
<p>Router(config)#int fa 0&#x2F;0</p>
<p>Router(config-if)#description To ISP</p>
<p>6）关闭域名解析功能：</p>
<p>Router(config)#no ip domain-lookup</p>
<p>7）将实验端口恢复默认设置：</p>
<p>Router(config)#default interface f0&#x2F;0</p>
<p>8）设置系统时间：</p>
<p>Router#clock set 08:00:00 1jan 2016 </p>
<p>9)给路由器命名：</p>
<p>进入全局配置模式，用hostname<name>命令来设定路由器名称</p>
<p>10）给端口配IP地址：在全局配置模式下，进入各端口配置模式配置IP地址</p>
<p>​        1.以太网口配置</p>
<p>​            Router(config)# int f0&#x2F;0</p>
<p>​            Router(config-if) #ip address <ip address><subnet mask></p>
<p>​            Router(config-if)# no shutdown</p>
<p>​        2.串行线：根据串口是DTE还是DCE来选择（略）</p>
<p>11）Ping命令</p>
<p>Router#ping <ip address></p>
<p>12）设置Telnet</p>
<p>能进行Telnet的前提：主机能ping通路由器；路由器设置了telnet密码；路由器允许通过telnet登录；如果需要进入特权模式，还需要配置enable密码。</p>
<p>配置命令：Router#telnet <ip address></p>
<p>​                   Router#telnet <hostname></p>
<p>启动telnet：</p>
<p>Router#config t</p>
<p>Router(config)#line vty 0 4 &#x2F;&#x2F;同时允许0-4共5个连接</p>
<p>Router(config-line)# login</p>
<p>Router(config-line)#password cisco &#x2F;&#x2F;设置密码为cisco</p>
<p>设置enable密码：</p>
<p>Router(config)#enable password cisco</p>
<p>Router(config-line)# password cisco</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>1）连接方法同路由器</p>
<p>2）将hostname改为nju</p>
<p>先enable进入特权模式，在con t 进入全局配置模式（命令在不引起歧义的情况下可以省略），然后</p>
<p>Switch(config)#hostname nju</p>
<p>3）设置特权密码和vty线路密码</p>
<p>nju(config)#enable password ccna</p>
<p>nju(config)#line vty 0 4</p>
<p>nju(config-line)#passwoed ccnp</p>
<p>4）设置管理ip地址</p>
<p>nju(config)#inter vlan1</p>
<p>nju(config-if)#ip add 192.168.1.1 255.255.255.0</p>
<p>nju(config-if)#no shut</p>
<p>nju(config-if)#exit</p>
<p>nju(config)#ip default0gateway 192.168.1.100</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ sort</title>
    <url>/2022/04/14/C++sort/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(a,a+<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>加入sort函数样板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">less&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">less_equal&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">greater&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">greater_equal&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">equal_to&lt;Type&gt;</span><br><span class="line"></span><br><span class="line">not_equal_to&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(arr, arr+<span class="number">10</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), mycompare);</span><br></pre></td></tr></table></figure>

<p>配合lambda匿名函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::sort(v.begin(), v.end(), [](int a, int b)&#123;</span><br><span class="line">    return a &lt; b; // 升序排列</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot</title>
    <url>/2022/04/12/Springboot/</url>
    <content><![CDATA[<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="创建第一个springboot项目"><a href="#创建第一个springboot项目" class="headerlink" title="创建第一个springboot项目"></a>创建第一个springboot项目</h2><p>1.File-&gt;创建maven-&gt;导入父工程，添加web依赖-&gt;在Java文件夹中创建class（有很多层文件夹）-&gt;添加注解@SpringBootApplication,创建main函数-&gt;创建controller，添加注解@Controller，添加注解@RequestMapping，添加注解@ResponseBody，可以和Controller合二为一，变为@RestController-&gt;run</p>
<p>2.修改端口：在resources中创建application.properties，在其中添加server.port&#x3D;8888</p>
<ol start="3">
<li></li>
</ol>
]]></content>
      <tags>
        <tag>后端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Vector浅析</title>
    <url>/2022/04/11/C++vector%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="C-Vector浅析"><a href="#C-Vector浅析" class="headerlink" title="C++Vector浅析"></a>C++Vector浅析</h1><h2 id="一、什么是vector？"><a href="#一、什么是vector？" class="headerlink" title="一、什么是vector？"></a>一、什么是vector？</h2><p>vector就是一个封装了动态大小数组的顺序容器。和任意其他类型容器一样，它能够存放各种类型的对象。可以简单认为，是一个能够存放任意类型的动态数组。</p>
<h2 id="二、容器特性"><a href="#二、容器特性" class="headerlink" title="二、容器特性"></a>二、容器特性</h2><h3 id="1-顺序排列"><a href="#1-顺序排列" class="headerlink" title="1.顺序排列"></a>1.顺序排列</h3><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2.动态数组"></a>2.动态数组</h3><h3 id="3-能够感知内存分类器的（Allocator-aware）"><a href="#3-能够感知内存分类器的（Allocator-aware）" class="headerlink" title="3.能够感知内存分类器的（Allocator-aware）"></a>3.能够感知内存分类器的（Allocator-aware）</h3><h2 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><p>创建空vector：vector()</p>
<p>创建一个vector，元素的个数为nSize：vector(int nSize)</p>
<p>创建一个vector，元素个数为nSize，且值均为t：vector(int nSize,const t&amp; t)</p>
<p>复制构造函数：vector(const vector&amp;)</p>
<p>复制[begin,end)区间内的元素到另一个vector中：vector(begin,end)</p>
<h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul>
<li>iterator erase(iterator it):删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li>
<li>void pop_back():删除向量中最后一个元素</li>
<li>void clear():清空向量中所有元素</li>
</ul>
<h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul>
<li>reference at(int pos):返回pos位置元素的引用</li>
<li>reference front():返回首元素的引用</li>
<li>reference back():返回尾元素的引用</li>
<li>iterator begin():返回向量头指针，指向第一个元素</li>
<li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li>
</ul>
<h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul>
<li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li>
</ul>
<h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul>
<li>int size() const:返回向量中元素的个数</li>
<li>int capacity() const:返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const:返回最大可允许的vector元素数量值</li>
</ul>
<h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul>
<li>void swap(vector&amp;):交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li>
</ul>
<h3 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h3><blockquote>
<p>1.push_back 在数组的最后添加一个数据</p>
<p>2.pop_back 去掉数组的最后一个数据</p>
<p>3.at 得到编号位置的数据</p>
<p>4.begin 得到数组头的指针</p>
<p>5.end 得到数组的最后一个单元+1的指针</p>
<p>6.front 得到数组头的引用</p>
<p>7.back 得到数组的最后一个单元的引用</p>
<p>8.max_size 得到vector最大可以是多大</p>
<p>9.capacity 当前vector分配的大小</p>
<p>10.size 当前使用数据的大小</p>
<p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p>
<p>12.reserve 改变当前vecotr所分配空间的大小</p>
<p>13.erase 删除指针指向的数据项</p>
<p>14.clear 清空当前的vector</p>
<p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p>
<p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p>
<p>17.empty 判断vector是否为空</p>
<p>18.swap 与另一个vector交换数据</p>
</blockquote>
<h2 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt; vector&gt; </span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、简单介绍"><a href="#五、简单介绍" class="headerlink" title="五、简单介绍"></a>五、简单介绍</h2><ol>
<li>Vector&lt;类型&gt;标识符</li>
<li>Vector&lt;类型&gt;标识符(最大容量)</li>
<li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li>
<li>Int i[5]&#x3D;{1,2,3,4,5}<br>Vector&lt;类型&gt;vi(I,i+2);&#x2F;&#x2F;得到i索引值为3以后的值</li>
<li>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量&#x2F;&#x2F;这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li>
</ol>
<p>具体使用见<a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>
<h2 id="六、求vector或者数组中的最大值"><a href="#六、求vector或者数组中的最大值" class="headerlink" title="六、求vector或者数组中的最大值"></a>六、求vector或者数组中的最大值</h2><p>可以用max_element()和min_element()函数，二者返回的都是迭代器或指针.</p>
<p>头文件：<code>#include&lt;algorithm&gt;</code></p>
<p>vector容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>())-v.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>普通数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//最大值：</span></span><br><span class="line"><span class="type">int</span> maxValue = *<span class="built_in">max_element</span>(a,a+<span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> maxPosition = <span class="built_in">max_element</span>(a,a+<span class="number">6</span>)-a;</span><br></pre></td></tr></table></figure>

<h2 id="七、在指定位置插入元素"><a href="#七、在指定位置插入元素" class="headerlink" title="七、在指定位置插入元素"></a>七、在指定位置插入元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用insert，格式一样，可以插入多个元素。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++STL</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在hexo上创建一篇文章</title>
    <url>/2022/04/11/%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="新建文章："><a href="#新建文章：" class="headerlink" title="新建文章："></a>新建文章：</h2><p>使用命令来新建文章：<br><code>hexo new [layout] &lt;title&gt;</code><br>layout是文章的布局，默认为post，可以先不写。<br>title是文章的标题，也是文件的名字，存储在source&#x2F;_posts下。<br>然后再MarkDown编辑器上打开编辑。</p>
<h2 id="Font-matter设置"><a href="#Font-matter设置" class="headerlink" title="Font-matter设置"></a>Font-matter设置</h2><p>Font-matter是文章最上方分隔的区域，用于指定文章的变量设置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
<td>无</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>无</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>update</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
<td>（不适用于分页）</td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
<td>（不适用于分页）</td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
<td>无</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>截断，用于显示更多。</p>
<p>之后用hexo g &amp; hexo d 就可以啦！</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
