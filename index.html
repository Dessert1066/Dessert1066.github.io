<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="hey">
<meta property="og:type" content="website">
<meta property="og:title" content="小戎的学习历程">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="小戎的学习历程">
<meta property="og:description" content="hey">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="戎菜菜">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>小戎的学习历程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小戎的学习历程</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">梦想下酒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/C++STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/C++STL/" class="post-title-link" itemprop="url">C++ STL Stack Queue Deque PriorityQueue Pair</a>
        </h2>

        <div class="post-meta">

    <i class="fa fa-thumb-tack"></i>
    <font color=7D26CD>置顶</font>
    <span class="post-meta-divider">|</span>

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 13:57:42" itemprop="dateCreated datePublished" datetime="2022-04-14T13:57:42+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-20 09:03:52" itemprop="dateModified" datetime="2022-05-20T09:03:52+08:00">2022-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）"><a href="#C-Stack-Queue-Deque-PriorityQueue-Pair-（Vector-Set略）" class="headerlink" title="C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）"></a>C++ Stack Queue Deque PriorityQueue Pair （Vector Set略）</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack:"></a>Stack:</h2><p>头文件：</p>
<p><code>#include&lt;stack&gt;</code></p>
<p>简介：</p>
<p>stack（栈），是一种后进先出（Last-In-First-Out，LIFO）的线性结构，支持两种操作：push和pop。</p>
<p>push操作是把一个元素加入栈中，pop操作是把最晚进入的元素删除。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/14/C++STL/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/18/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/18/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="post-title-link" itemprop="url">内联函数的特点及注意事项</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-18 08:57:44 / 修改时间：09:16:35" itemprop="dateCreated datePublished" datetime="2022-06-18T08:57:44+08:00">2022-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果代码中有一些函数频繁地被调用，那么会不断地函数参数入栈、出栈，造成代码时间上的浪费。为了解决这个问题，特别引入了inline修饰符，表示内联函数。</p>
<p>内联函数就和带参数宏类似，都是使用函数体直接替换调用出地代码，所以不需要参数入栈和出栈，节约了时间。</p>
<p>但是需要注意地是，内联函数只适合函数功能简单，操作少，被调用多的情况下，这样才能对代码效率进行提升。当内联函数中，函数体功能复杂，需要循环、嵌套等大量操作，那么当内联函数体在编译时替换调用处的代码，会占据大量的内存，而且变异的时间也有可能会大大增加，造成的影响远远大于不适用内联函数。</p>
<p>内联函数与带参数宏定义的区别：</p>
<ol>
<li><p>宏调用并不执行类型检查（任意类型皆可），但是函数调用却要检查</p>
</li>
<li><p>宏替换发生在预处理阶段，函数发生在编译阶段</p>
</li>
<li><p>宏是简单的文本替换，会出现意想不到的错误，而函数不会。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x, y) x * y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mul(a, b) = &quot;</span> &lt;&lt; <span class="built_in">mul</span>(a+b, c+d) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MUL(a, b) = &quot;</span> &lt;&lt; <span class="built_in">MUL</span>(a+b, c+d) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：内联函数add的结果是正确的，但是宏ADD是错误的，那么为什么是11呢？只要展开就明白了；调用点展开：<code>cout &lt;&lt; &quot;ADD(a, b) = &quot; &lt;&lt; 1+2*3+4 &lt;&lt;endl;</code>那么结果肯定是11啊，所以对于经验不是特别丰富的程序员使用带参数宏，很容易出现错误！</p>
<p>那么有经验的该怎么写呢？<code>#define ADD(x, y) ((x) * (y))</code>，这样，就不会出错了！</p>
</li>
</ol>
<p>内联函数的定义一般直接写在头文件中，因为内联函数在编译时是直接将函数体替换调用点的代码，所以如果内联函数定义在某xx.cc中，声明是定义在头文件中，那么当调用内联函数的时候，在编译阶段调用该内联函数的代码替换成函数体，那么就不会再有该内联函数的函数名了，链接器自然无法解析。</p>
<p>当然你如果非要将内联函数声明写在头文件，定义在xx.cc中，然后还想在aa.cc中调用在xx.cc中的内联函数，那么需要在头文件中加上<code>#include &quot;xx.cc&quot;</code>，这种写法多此一举，不建议这样操作！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/18/C++%E9%87%8C%E9%9D%A2%E7%9A%84%E9%87%8D%E5%86%99%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/18/C++%E9%87%8C%E9%9D%A2%E7%9A%84%E9%87%8D%E5%86%99%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">C++里面的重写带有默认参数的虚函数的问题</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-18 08:39:47 / 修改时间：08:48:06" itemprop="dateCreated datePublished" datetime="2022-06-18T08:39:47+08:00">2022-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在C++里面虚函数是实现多态的主要方式。而虚函数的实现是在运行时通过查找虚函数里面的函数指针来实现对于不同的子类的虚函数的调用。注意到这里虚函数的调用是<b>运行时</b>的。</p>
<p>而默认参数则是C++方便程序员在定义函数的时候当一些默认情况下，给定默认值的一种方式。主义到默认参数的传递是在编译器由编译器确定的。也就是说如果有下面的函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string&amp; s = <span class="string">&quot;hello, world!&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>hello()</code>的时候，会传递默认的<code>&quot;hello,world!&quot;</code>给<code>hello()</code>。</p>
<p>那么，如果类里面的虚函数定义了默认参数，情况又是怎么样呢？</p>
<p>试想这样一种情况，定义一个基类Base，定义函数虚函数ShowMessage(int i &#x3D; 1)，而<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020">子类</a>Derived继承于Base，重写了ShowMessage(int i &#x3D; 2)。也就是如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::ShowMessage</span><span class="params">( <span class="type">int</span> i <span class="comment">/*= 1*/</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i = <span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::ShowMessage</span><span class="params">( <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Derived: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么运行下面的程序的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *a = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived b;</span><br><span class="line"> </span><br><span class="line">a-&gt;<span class="built_in">ShowMessage</span>(); <span class="comment">// output: Derived: 1</span></span><br><span class="line">b.<span class="built_in">ShowMessage</span>();  <span class="comment">// output: Derived: 2</span></span><br></pre></td></tr></table></figure>

<p>第2行的结果应该是和语气中一样的，但是第一行为什么是1不是2呢？</p>
<p>原因就在于默认参数的确定是在编译器完成的，而在编译过程中，编译器并不知道a指向的实际上是Base还是Derived，所以它就把a当成是Base，而Base的ShowMessage的默认参数是1，传给第一个参数的值是1。而到了程序运行时，由于多态性，ShowMessage调用的是Derived的ShowMessage，只不过参数是1而已。</p>
<p>由于这个原因，在重写带有默认参数的虚函数的时候，一定要和原来的参数一样，不然会造成很多问题。</p>
<p>那么，如果我们在Derived中定义的ShowMessage不带有默认参数呢？如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowMessage</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而主程序调用b.ShowMessage()。</p>
<p>结果是程序在b.ShowMessage()处出现编译错误。原因是当虚函数带有默认参数的时候，如果想要重写的话，则参数表里面的默认参数的位置必须是对应的。如果基类中的虚函数是带有默认参数，而子类的没有，则虽然类型是一样的，编译器是认为这两个函数是不一样的。那么子类中的函数就是代替了基类中的函数。具体可以看《C++ Primer》的P593。</p>
<p>如果想要通过上面的编译，需要在Derived的定义中加入using Base::ShowMessage;这句话。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/16/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/16/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" class="post-title-link" itemprop="url">近代史纲要</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-16 08:43:13 / 修改时间：08:44:02" itemprop="dateCreated datePublished" datetime="2022-06-16T08:43:13+08:00">2022-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" itemprop="url" rel="index"><span itemprop="name">近代史纲要</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="列强的入侵战争及签订条约"><a href="#列强的入侵战争及签订条约" class="headerlink" title="列强的入侵战争及签订条约"></a>列强的入侵战争及签订条约</h3><ol>
<li><p>1840-1842年，第一次鸦片战争，签订南京条约。</p>
<p>南京条约内容：（1）割让香港岛；（2）赔偿英国二千一百万银元；（3）五口通商，开放广州、福建、厦门、宁波、上海为通商口岸，允许英国人居住并设派领事；（4）协定关税；（5）允许英国商人在华自由贸易等</p>
<p>影响：破坏了中国的领土完整和关税主权，中国开始沦为半殖民地半封建社会。</p>
</li>
<li><p>1856-1860年，第二次鸦片战争，签订天津条约和北京条约。</p>
<p>天津条约内容：（1）公使常驻北京；（2）开放牛庄、登州、台湾、淡水、潮州、琼州、汉口、九江、南京、镇江为通商口岸；（3）传教人士自由传教；（4）对英国赔款400万两，对法国赔款200万两。</p>
<p>北京条约内容：（1）承认天津条约有效；（2）开放天津为商埠；（3）割让九龙司地方一区给英国；（4）允许英法招募华工出国；（5）对英法的赔款各增至800万两</p>
<p>影响：1. 丧失的领土和主权增多，英国割让九龙司地方一区，沙俄占中国100多万平方公里；外国公使进驻北京的规定，更为外国侵略者直接控制清政府准备了条件。2. 外国侵略势力的深入及扩展，第二次鸦片战争之后，中国又增开了天津在内的11处通商口岸，使外国侵略势力从东南沿海扩展到整个沿海，从沿海深入到内地。3. 中国的半殖民地半封建程度进一步加深。</p>
</li>
<li><p>1894年，中日甲午战争，签订马关条约</p>
<p>马关条约内容：（1）割让辽东半岛、台湾岛以及其附属各岛屿、澎湖列岛给日本；（2）赔偿日本军费白银两亿两；（3）开放沙市、重庆、苏州、杭州为商埠；（4）允许日本在中国的通商口岸投资办厂。</p>
<p>影响：（1）台湾等大片领土的割让，进一步破坏了中国主权的完整，刺激列强瓜分中国的野心，民族危机进一步加深；（2）巨额赔款加重了中国人民的负担，同时加速了日本军国主义的发展。清政府因此大借外债，使列强控制了中国的经济命脉；（3）通商口岸的开放，使帝国主义侵略势力深入到中国内地。允许在华投资办厂，严重阻碍了民族资本主义的发展；（4）中国半殖民地半封建程度大大加深。</p>
</li>
<li><p>1900年，八国联军侵华战争，签订辛丑条约</p>
<p>辛丑条约内容：（1）对各国赔款4.5亿两，价息合计超过9.8亿两白银，并以关税和盐税作为抵押；（2）划定北京东交民巷为使馆界，允许各国驻兵保护，不允许中国人在界内居住；（3）拆毁天津大沽口到北京沿线设防的炮台，允许各国驻兵北京到山海关铁路沿线要地；（4）清政府保证严禁人民参加反帝运动；（5）改总理各国事务衙门为外务部，班列六部之前等</p>
<p>影响：辛丑条约的签订，进一步加强了帝国主义对中国的全面控制和掠夺，表明清政府已经完全沦为帝国主义统治中国的工具，标志着中国已经完全沦为半殖民地半封建社会。</p>
</li>
</ol>
<h3 id="早期的维新思想"><a href="#早期的维新思想" class="headerlink" title="早期的维新思想"></a>早期的维新思想</h3><ol>
<li>林则徐是近代中国睁眼看世界的第一人，进行查禁鸦片和抗英斗争，编成《四洲志》，讲述世界地理。</li>
<li>魏源在1843年编成《海国图志》，提出“师夷长技以制夷”的思想，主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略。</li>
<li>严复翻译《天演论》，用“物竞天择”“适者生存”的社会进化论思想，为救亡图存提供了理论根据。</li>
<li>19 世纪 70 年代以后，郑观应等人不仅主张学习西方的科学技术，同时也要求吸纳西方的政治、经济学说。如郑观应在所著《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张。这些主张具有重要的思想启蒙的意义。</li>
<li>孙中山1894年成立兴中会，喊出“振兴中华”的口号。</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="太平天国运动失败的原因"><a href="#太平天国运动失败的原因" class="headerlink" title="太平天国运动失败的原因"></a>太平天国运动失败的原因</h3><ol>
<li>农民阶级不是新的生产力和生产关系的代表，无法克服小生产者所固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导，因而无法从根本上提出完整的、正确的政治纲领和社会改革方案。</li>
<li>太平天国无法制止和克服领导集团腐败现象的滋生。</li>
<li>太平天国军事战略上出现了重大失误。</li>
<li>太平天国是以宗教来发动、组织群众的，但是，拜上帝教不仅不能正确指导斗争，而且给农民带来了危害。</li>
<li>太平天国未能正确对待儒学。</li>
<li>太平天国不能把西方国家的侵略者和人民群众区别开来，对西方资本主义侵略者缺乏理性的认识。</li>
</ol>
<h3 id="洋务运动起到的历史作用"><a href="#洋务运动起到的历史作用" class="headerlink" title="洋务运动起到的历史作用"></a>洋务运动起到的历史作用</h3><p>洋务派提出“自强”“求富”的主张，通过所掌握的国家权力集中力量优先发展军事工业，同时也试图“稍分洋商之利”，发展若干民用企业，在客观上对中国早期工业和民族资本主义的发展起了某些促进作用。但是，洋务派兴办洋务新政，主要是为了维护封建统治，并不是要使中国朝着独立的资本主义方向发展。</p>
<p>洋务运动时期，为了培养通晓洋务的人才，开办了一批新式学堂，派出了最早的官派留学生，这是中国近代教育的开始。与此同时，还翻译了一批近代自然科学书籍，给当时的中国带来了新的知识，使人们开阔了眼界。</p>
<p>洋务运动时期，伴随着资本主义生产方式的出现，传统的“重本抑末”等观念收到冲击，社会风气和价值观念开始变化，工商业者的地位上升。对一部分人来说，西方的各种技术和器物不再被当作“奇技淫巧”受到排斥，而是被视为模仿、学习的对象。这一切，都有利于资本主义经济的发展，也有利于社会风气的改变。</p>
<h3 id="戊戌变法的内容"><a href="#戊戌变法的内容" class="headerlink" title="戊戌变法的内容"></a>戊戌变法的内容</h3><p>政治方面：改革行政机构，裁撤闲散、重叠机构；裁汰冗员，澄清吏治，提倡倡廉；提倡向皇帝上书言事；准许旗人自谋生计，取消国家供养的特权。</p>
<p>经济方面：保护、奖励工农商业和交通采矿业，中央设立农工商总局与铁路矿物总局，各省设立商务局；提倡开办实业，奖励发明创造；注重农学发展，提倡西法耕植，建立新式农场；广办邮政，修筑铁路；开办商学、商报，设立商会等各类组织；改革财政，编制国家预决算。</p>
<p>军事方面：裁剪旧式绿营兵，改练新式陆军；采用西洋兵制，练洋操，习洋枪等。</p>
<p>文化教育方面：创设京师大学堂，各省书院改为高等学堂，在各地设立中、小学堂；提倡西学，废除八股，改试策论，开经济特科；设立译书局，翻译国外书籍，派人出国留学；奖励新著，奖励创办报刊，允许自由组织学会。</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="清末革命与改良的辩论"><a href="#清末革命与改良的辩论" class="headerlink" title="清末革命与改良的辩论"></a>清末革命与改良的辩论</h3><p>1905至1907年，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派分别以《民报》《新民丛报》为主要舆论阵地，展开了一场大论战。</p>
<ol>
<li><p>要不要以革命手段推翻清王朝</p>
<p>改良派认为，革命会引起下层社会暴乱，招致外国干涉、瓜分，使中国“血流成河”“亡国灭种”，所以要爱国就不能革命，只能改良、立宪。</p>
<p>革命派针锋相对地之处，清政府是帝国主义的“鹰犬”，因此爱国必须革命。只有通过革命，才能“免瓜分之祸”，获得民族独立和社会进步。</p>
<p>革命牌还进一步驳斥了改良派认为因革命要“杀人流血”“破坏一切”而不可革命地说法。他们指出：</p>
<p>第一，进行革命，固然会有牺牲，但是，不进行革命，而容忍清王朝在中国的统治，中国人民将长期地遭受痛苦和做出更大的牺牲。</p>
<p>第二，人们在革命过程中所付出的努力，乃至作出的牺牲，是以换取历史的进步作为补偿的。</p>
</li>
<li><p>要不要推翻帝制，实行共和</p>
<p>改良派认为，中国“国民恶劣”“智力低下”，没有实行民主共和政治的能力。如果实行，非亡国不可。因此，实行君主立宪才是中国政治的现实出路。</p>
<p>革命派指出，不是“国民恶劣“，而是”政府恶劣“。民主共和是大势所趋，人心所向。拯救中国与建设中国都必须取法乎上，直接推行民主制度，而不能以国民素质低劣为借口，搞君主立宪甚或开明专制。只有”兴民权改民主“，才是中国的唯一出路。中国国民自有颠覆专制制度、建立民主共和的能力。</p>
</li>
<li><p>要不要进行社会革命</p>
<p>改良派反对土地国有，反对平均地权。他们认为，中国社会经济组织优良，土地问题不是中国最重要的问题，不存在社会革命的可能。社会革命只会导致中国的大动乱。他们还攻击主张平均地权是煽动乞丐流氓，主张土地国有是危害国本，并表示在这个问题上”宁死不让“。</p>
<p>革命派强调，当时的中国存在着严重的”地主强权“”地权失平“的现象。必须通过平均地权以实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等社会问题的出现。</p>
</li>
</ol>
<p>这场论战划清了革命与改良的界限，传播了民主革命思想，促进了革命形势的发展。但这场论战也暴露了革命派在思想理论方面的弱点。</p>
<h3 id="反清革命团体（同盟会）"><a href="#反清革命团体（同盟会）" class="headerlink" title="反清革命团体（同盟会）"></a>反清革命团体（同盟会）</h3><h4 id="同盟会的成立"><a href="#同盟会的成立" class="headerlink" title="同盟会的成立"></a>同盟会的成立</h4><p>1905 年 8 月 20 日，孙中山等人以兴中会和华兴会为基础，在日本东京成立中国同盟会，孙中山被公举为总理。同盟会以《民报》为机关报，并确定了革命纲领。这是近代中国第一个领导资产阶级革命的全国性政党，它的成立标志着中国资产阶级民主革命进入了一个新的阶段。</p>
<p>同盟会的政治纲领是“驱除鞑虏，恢复中华，创立民国，平均地权”。孙中山其概括为三大主义，即民族主义、民权主义、民生主义，后被称为三民主义。</p>
<p>但是，同盟会纲领中的民族主义没有从正面鲜明地提出反对帝国主义的主张。当时的革命派对于帝国主义的本质认识不清，害怕帝国主义干涉，甚至幻想以承认不平等条约“继续有效”为条件来换取列强对自己的支持。同时，他们也没有明确地把汉族军阀、官僚、地主作为革命对象，从而给了这部分人后来从内部和外部破坏革命以可乘之机。</p>
<h4 id="同盟会领导的武装斗争"><a href="#同盟会领导的武装斗争" class="headerlink" title="同盟会领导的武装斗争"></a>同盟会领导的武装斗争</h4><p>孙中山领导的同盟会不仅提出了革命纲领，而且从事实际的革命活动，产生了广泛的影响。其中影响最大的是 1911年 4 月 27 日举行的广州起义。是日，黄兴率敢死队 120 余人在广州举行起义，大部在激战中牺牲。其中 72 位烈士的遗骸被葬于黄花岗，故是役史称“黄花岗起义”。</p>
<p>1911 年 5 月，清政府宣布“铁路干线收归国有”，借“国有”名义把铁路利权岀卖给帝国主义，同时借此“劫夺”商股。这激起了湖北、湖南、广东、四川四省的保路风潮，其中以四川为最烈。立宪派本来主张把保路运动限制在“文明争路”的范围之内，但署理四川总督赵尔丰竟下令军警向手无寸铁的请愿群众开枪，造成“成都血案”。广大群众忍无可忍，在同盟会成员的参与下，掀起了全川的武装暴动，史称保路运动。</p>
<h3 id="辛亥革命的历史意义"><a href="#辛亥革命的历史意义" class="headerlink" title="辛亥革命的历史意义"></a>辛亥革命的历史意义</h3><p>辛亥革命是资产阶级领导的以反对封建君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产阶级民主革命。</p>
<p>第一，辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。在这以后，帝国主义和封建势力在中国再也不能建立起比较稳定的统治，从而为中国人民斗争的发展开辟了道路。</p>
<p>第二，辛亥革命结束了中国延续两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心，并在中国形成了”敢有帝制自为者，天下共击之“的民主主义观念。</p>
<p>第三，辛亥革命推动了中国人民的思想解放，激发了人民的爱国热情和民族觉醒，打开了禁锢思想进步的闸门。</p>
<p>第四，辛亥革命推动了中国的社会变革，促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。</p>
<p>第五，辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨。</p>
<h3 id="辛亥革命失败的原因"><a href="#辛亥革命失败的原因" class="headerlink" title="辛亥革命失败的原因"></a>辛亥革命失败的原因</h3><ol>
<li>从根本上来说，是因为在帝国主义时代，在半殖民地半封建的中国，资本主义的建国方案是行不通的，帝国主义绝不允许中国建立一个独立、富强的资产阶级共和国，从而使自己失去剥削、奴役的对象。</li>
<li>从主观方面来说，在于它的领导者资产阶级革命派本身存在着许多弱点和错误。第一，没有提出彻底的反帝反封建的革命纲领。第二，不能充分发动和依靠人民群众。第三，不能建立坚强的革命政党，作为团结一切的革命力量的强有力的核心。</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="五四运动爆发的原因"><a href="#五四运动爆发的原因" class="headerlink" title="五四运动爆发的原因"></a>五四运动爆发的原因</h3><p>五四运动是在新的时代条件和社会历史条件下发生的。</p>
<p>首先，是新的社会力量的成长、壮大。第一次世界大战期间，中国的资本主义经济得到迅速发展，中国资产阶级和工人阶级也进一步成长起来，五四运动获得了比以往革命斗争更加广泛的群众基础。</p>
<p>其次，是新文化运动掀起的思想解放潮流，年轻一代知识界，尤其是初步具有共产主义思想的知识分子，为五四运动准备了最初的群众队伍和骨干力量。</p>
<p>最后，是俄国十月革命对中国的影响。</p>
<h3 id="五四运动的过程"><a href="#五四运动的过程" class="headerlink" title="五四运动的过程"></a>五四运动的过程</h3><p>五四运动的直接导火线，是巴黎和会上中国外交的失败。五四运动开始时，英勇地出现在斗争前面的是学生。学生的爱国行动遭到北洋政府的严厉镇压。在此关口，中国工人阶级开始以独立的姿态登上政治舞台。随后，这场反帝爱国运动扩展到了20多个省区，100多个城市。</p>
<p>这时，五四运动突破了知识分子的狭小围，成为有工人阶级、小资产阶级和民族资产阶级参加的全国规模的革命运动。斗争的主力由学生转向了工人，运动的中心由北京转到了上海。迫于人民群众的压力，中国政府没有出席巴黎和约签字仪式，五四运动的直接斗争目标得以实现。</p>
<h2 id="五四运动的历史特点和意义"><a href="#五四运动的历史特点和意义" class="headerlink" title="五四运动的历史特点和意义"></a>五四运动的历史特点和意义</h2><p>由于五四运动是在新的社会历史条件下发生的，它具有以辛亥革命为代表的旧民主主义革命所不具备的历史特点，具有伟大意义。</p>
<p>就特点来看，五四运动是一场以先进青年知识分子为先锋、广大人民群众参与的彻底反帝反封建的伟大爱国革命运动，是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化新知识的伟大思想启蒙运动和新文化运动，以磅礴之力鼓动了中国人民和中华民族实现民族复兴的志向和信心。</p>
<p>就意义看，第一，五四运动是中国旧民主主义革命走向新民主主义革命的转折点，具有里程碑意义。它以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上干部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件。第二，五四运动孕育了以爱国、进步、民主、科学为主要内容的伟大五四精神，其核心是爱国主义。第三，五四运动改变了以往只有觉悟的革命者而缺少觉醒的人民大众的斗争状况，实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒。</p>
<p>总之，五四运动标志着中国新民主主义革命的开端。</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="长征的起因和经过"><a href="#长征的起因和经过" class="headerlink" title="长征的起因和经过"></a>长征的起因和经过</h3><h4 id="遵义会议"><a href="#遵义会议" class="headerlink" title="遵义会议"></a>遵义会议</h4><p>1934 年 10 月中旬，中共中央和中央红军 8.6 万人撤离根据地，向西突围转移，开始长征。其后，1935 年 3 月、4 月，红四方面军从川陕根据地出发长征。同年 11月，红二、六军团（后组成红二方面军）从湘鄂川黔根据地出发长征。</p>
<p>1935 年 1 月 15 日至 17 日召开了遵义会议。</p>
<p>遵义会议批评了博古、李德在第五次反“围剿”中的错误，增选毛泽东为中央政治局常务委员，做出了军事、组织方面的一系列重大决策，是在中国共产党同共产国际的联系中断的情况下，独立自主地作出的。</p>
<p>遵义会议开始确立以毛泽东为主要代表的马克思主义的正确路线在党中央的领导地位，从而在极其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，成为中国共产党历史上一个生死攸关的转折点。这为党和革命事业转危为安、不断打开新局面提供了最重要的保证。</p>
<h4 id="红军长征的胜利"><a href="#红军长征的胜利" class="headerlink" title="红军长征的胜利"></a>红军长征的胜利</h4><p>遵义会议后，在毛泽东等的领导下，中央红军采取灵活机动的战略战术，四渡赤水河，巧渡金沙江，抢渡大渡河，翻越人迹罕至、终年积雪的夹金山，摆脱了数十万国民党军队的围追堵截，赢得了战争的主动权。随后中共中央决定将北上红军改称陕甘支队，先行北上，于 10 月 19 日到达陕北吴起镇；11 月初，同红十五军团会合，中国共产党所领导的革命力量有了新的落脚点和战略基地。至此，中央红军的二万五千里长征胜利结束。1936 年 10 月，红二、四方面军先后同红一方面军会师。至此，三大主力红军的长征胜利结束。</p>
<h3 id="长征胜利的意义"><a href="#长征胜利的意义" class="headerlink" title="长征胜利的意义"></a>长征胜利的意义</h3><p>长征的胜利，极大地促进了党在政治上和思想上的成熟；</p>
<p>是中国革命转危为安的关键；</p>
<p>宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败，宣告了中国共产党和红军胜利实现了北上抗日的战略转移，实现了中国革命事业从挫折走向胜利的伟大转折，开启了中国共产党为实现民族独立、人民解放而斗争的新的伟大进军。</p>
<p>长征铸就了伟大的长征精神，开启了中国革命的新局面。</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="九一八事变、华北事变、卢沟桥事变"><a href="#九一八事变、华北事变、卢沟桥事变" class="headerlink" title="九一八事变、华北事变、卢沟桥事变"></a>九一八事变、华北事变、卢沟桥事变</h3><p>1931年9月18日深夜，日本关东军炸毁“南满铁路“沈阳的一段路轨，反诬中国军队所为，当即炮轰东北军驻地北大营，接着向沈阳城等地发起进攻，这就是九一八事变。九一八事变是中国抗日战争的起点，标志着中国局部抗战的开始。</p>
<p>1935年，日本在华北制造一系列争端，中国在河北、察哈尔两省的主权大部丧失，华北成为日军可以自由出入的”真空地带“。接着，日本策动华北五省两市的”防共自治运动“，制造傀儡政权，这就是华北事变。</p>
<p>1937年7月7日，日军在卢沟桥以北进行军事演习，借口一名士兵失踪，要求进入宛平县城搜查，遭拒绝后开炮轰城，向中国驻军进攻。日本全面侵华战争由此开始。</p>
<p>由于遭到中国军民的顽强抵抗，日军在 1938 年 10 月占领广州、武汉以后，被迫停止对正面战场的战略性进攻。在坚持灭亡中国的总方针下，日本调整侵华政策，实施“以华制华”和“以战养战”策略，对国民党政府采取政治诱降为主、军事打击为辅的方针；在占领区加紧扶植傀儡政权，建立和发展汉奸组织；逐步将主要兵力用于对共产党领导的敌后抗日根据地进行“扫荡”。1944 年 4 月至 1945 年 1 月，日本发动豫湘桂战役，占领 20 多万平方公里的中国领土。这是日军在中国的最后一次大规模进攻。</p>
<h3 id="统一战线的形成"><a href="#统一战线的形成" class="headerlink" title="统一战线的形成"></a>统一战线的形成</h3><p>华北事变后，中日民族矛盾进一步激化。在中国共产党救亡图存、全民抗战的号召和地下党组织领导下，1935年12月9日北平学生举行抗日游行，喊出”停止内战，一致对外“的口号。由此开始的一二·九运动迅速波及全国。它促进了中华民族觉醒，标志着中国人民抗日救亡运动新高潮的到来。</p>
<p>中国共产党提出了建立抗日民族统一战线的政策，发表八一宣言，主张停止内战，组织国防政府和抗日联军。12月瓦窑堡召开政治局扩大会议，提出党的基本策略任务是建立广泛的抗日民族统一战线，批评了左倾主义倾向。</p>
<p>卢沟桥事变的第二天，中国共产党通电全国，号召全中国同胞团结起来，筑成抗日民族统一战线，建立八路军和新四军。为促进国共两党合作抗日，发表国共合作宣言，标志着以国共两党第二次合作为基础的抗日民族统一战线的正式形成。</p>
<h3 id="西安事变及其和平解决"><a href="#西安事变及其和平解决" class="headerlink" title="西安事变及其和平解决"></a>西安事变及其和平解决</h3><p>蒋介石“攘外必先安内”的方针并没有根本改变。1936年12月初，他到达西安，逼张学良、杨虎城“剿共”。张、杨在向蒋介石要求抗日遭拒后，于12日凌晨毅然实行“兵谏”，扣留蒋介石，并通电全国，提出停止内战、一致抗日等八项主张。这就是西安事变。</p>
<p>党中央派周恩来于17日到达西安。在弄清情况后，党中央以中华民族团结抗日大局为重，独立自主确定了用和平方式解决西安事变的方针。周恩来与张、杨共同努力，经过谈判，迫使蒋介石作出“停止剿共，联红抗日”的承诺。西安事变的和平解决成为时局转换的枢纽，十年内战局面基本结束，国内和平初步实现。</p>
<blockquote>
<p>为促进国共两党合作，1937年2月，中共中央致电国民党五届三中全会，提出停止内战等五项要求。如果国民党将这五项要求定为国策，共产党愿意实行包括停止武力推翻国民党政府的方针在内的四项保证。上述主张在全国引起巨大反响，也得到国民党内抗日派的赞同。国民党五届三中全会表示同意国共两党进行谈判，并在会议文件上第一次写上了“抗日”字样。</p>
<p>国共两党实行第二次合作成为不可抗拒的历史潮流。</p>
</blockquote>
<h3 id="论持久战的主要内容"><a href="#论持久战的主要内容" class="headerlink" title="论持久战的主要内容"></a>论持久战的主要内容</h3><p>1938年，毛泽东发表《论持久战》，总结全民族抗战10个月以来的经验，批驳了亡国论、速胜论等错误观点，系统的阐明了持久战方针。</p>
<p>毛泽东指出，中日战争是半殖民地半封建的中国和帝国主义的日本之间在20世纪30年代进行的一个决死的战争。一方面，日本是强国，中国是弱国，弱国强国的对比，决定了抗日战争只能是持久战。另一方面，日本是小国，发动的是退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，在国际上得道多助。中国已经有了代表中华民族和中国根本利益的、在政治上成熟的中国共产党以及其领导的抗日根据地和人民军队。因此，最后胜利又将是属于中国的。</p>
<p>毛泽东强调，”兵民是胜利之本“。战胜日本的侵略，必须进行人民战争。毛泽东科学遇见了抗日战争的发展进程，即抗日战争将经过战略防御、战略相持、战略反攻三阶段。战略相持是最关键阶段，只要坚持持久抗战、坚持抗日民族统一战线，中国将在这个阶段获得转弱为强的力量。</p>
<p>《论持久战》系统阐明了抗日战争的发展规律和坚持抗战、争取抗战胜利必须实行的战略总方针，是中国共产党领导抗日战争的纲领性文献，对全国抗战的战略指导产生了积极影响。</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="重庆谈判的起源和经过"><a href="#重庆谈判的起源和经过" class="headerlink" title="重庆谈判的起源和经过"></a>重庆谈判的起源和经过</h3><p>1945年8月14日、20日、23日，蒋介石三次电邀毛泽东到重庆“共定大计”。为了争取和平民主，毛泽东不顾个人安危，于8月28日偕周恩来、王若飞赴重庆与国民党当局进行谈判。这一行动，充分体现了中国共产党谋求和平的真诚愿望。10月10日，双方签署《政府与中共代表会谈纪要》，即“双十协定”，确认和平建国的基本方针，同意“长期合作，坚决避免内战”。</p>
<h3 id="三大战役"><a href="#三大战役" class="headerlink" title="三大战役"></a>三大战役</h3><p>三大战役是辽沈、淮海、平津三大战役。</p>
<p>辽沈战役自1948年9月12日开始至11月2日结束，历时52天。东北野战军主力70万人在林彪、罗荣桓领导下，共歼敌47.2万人。淮海战役自1948年11月6日开始至1949年1月10日结束，历时66天。华东野战军、中原野战军以及地方武装共60万人，在刘伯承、陈毅、邓小平、粟裕、谭震林组成的总前委（邓小平为书记）领导下，歼敌55.5万人。平津战役自1948年11月29日开始至1949年1月31日结束，历时64天。入关作战的东北野战军、华北解放军主力与地方武装共100万人，在由林彪、罗荣桓、聂荣臻组成的平津前线总前委领导下，歼灭和改编国民党军队52万余人。</p>
<p>三大战役历时4个月零19天，共歼灭国民党军队有生力量154万余人，加上1948年7月至1949年1月期间在济南战役和其他战役中的损失，国民党军队共丧失兵力230余万人。国民党赖以维持其反动统治的主要军事力量基本上被摧毁。</p>
<p>三大战役，无论是战争的规模还是取得的成果，在中国战争史上都是空前的，在世界战争史上也是罕见的。这是人民战争的胜利，是毛泽东军事思想的胜利。</p>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="论十大关系"><a href="#论十大关系" class="headerlink" title="论十大关系"></a>论十大关系</h3><p>重工业和轻工业、农业的关系；</p>
<p>沿海工业和内地工业的关系；</p>
<p>经济建设和国防建设的关系；</p>
<p>国家、生产单位和生产者个人的关系；</p>
<p>中央和地方的关系；</p>
<p>汉族和少数民族的关系；</p>
<p>党和非党的关系；</p>
<p>革命和反革命的关系；</p>
<p>是非关系；</p>
<p>中国和外国的关系</p>
<h3 id="七千人大会"><a href="#七千人大会" class="headerlink" title="七千人大会"></a>七千人大会</h3><p>1962年，七千人大会在北京召开。刘少奇代表中央提出的书面报告草稿，总结了“大跃进”以来经济建设工作的经验教训，分析了产生缺点错误的原因。毛泽东着重阐述了民主集中制的极端重要性，并带头做了自我批评，特别强调在社会主义建设上，我们还有很大的盲目性，今后要下苦功夫调查研究，弄清楚社会主义经济的规律。要使中国赶上和超过世界上最先进的资本主义国家，没有一百多年的时间是不行的。这是党中央和毛泽东对社会主义建设长期性的进一步认识。邓小平、周恩来分别代表中央书记处和国务院在大会上作自我批评，并提出恢复党的优良传统和克服目前困难的主要办法。这次会议发扬了党内的民主和自我批评精神，统一了全党的认识，对动员全党团结奋斗战胜困难起了极其重要的作用。</p>
<p>经过七千人大会前后近两年的挑战，到1965年底，大跃进和人民公社化运动带来的严重困难局面终于得到了改变。</p>
<h3 id="四个现代化"><a href="#四个现代化" class="headerlink" title="四个现代化"></a>四个现代化</h3><p>1964年底，周恩来在三届全国人大一次会议上提出实现“四个现代化”的历史任务，即“在不太长的历史时期内，把我国建设成一个具有现代农业、现代工业、现代国防和现代科学技术的社会主义强国，赶上和超过世界先进水平”。中央还确定分两步走实现现代化的战略构想，即从第三个五年计划开始，第一步，经过三个五年计划时期，建立一个独立的比较完整的工业体系和国民经济体系；第二步，全面实现农业、工业、国防和科学技术的现代化，使中国经济走在世界前列。“四个现代化”从此成为党和全国各族人民的共同奋斗目标，成为凝聚和团结全国各族人民不懈奋斗的强大精神力量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/15/Java%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/Java%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Java分层模型</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-15 09:59:43 / 修改时间：10:00:34" itemprop="dateCreated datePublished" datetime="2022-06-15T09:59:43+08:00">2022-06-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>表现层 presentation<br>业务逻辑层 service<br>数据持久层 dao</p>
<p>表示层(让控制层调用业务逻辑层显示数据，或者可以说直接使用业务逻辑层的数据。可以简单看成jsp页面)</p>
<p>业务逻辑层(service比DAO更为细化处理判断提取出来的数据，例如对某一个操作的细化)<br>XXXServiceDao(简单看成变量，或指针) –(指向)–&gt;XXXServiceDaoImpl(简单看成是变量的赋值，或实际的值)</p>
<p>DAO层(DAO，简单处理判断从数据库中提取出来的数据。可以看成就是增删改查操作)</p>
<p>XXXDao(简单看成变量，或指针)–(指向)–&gt;XXXDaoImpl(简单看成是变量的赋值，或实际的值)</p>
<p><strong>总结</strong>:本来业务逻辑层是没有数据的，但是由于DAO层的数据被业务逻辑层使用（实际上是”面向接口”编程，造成的接口回调。在我看来，其实就是类之间的引用。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/15/%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">聚合与组合</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-15 09:56:46 / 修改时间：09:59:10" itemprop="dateCreated datePublished" datetime="2022-06-15T09:56:46+08:00">2022-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聚合和组合"><a href="#聚合和组合" class="headerlink" title="聚合和组合"></a>聚合和组合</h1><h2 id="聚合（整体和部分可以分开）"><a href="#聚合（整体和部分可以分开）" class="headerlink" title="聚合（整体和部分可以分开）"></a>聚合（整体和部分可以分开）</h2><p>聚合关系表示一个整体与部分的关系，通常在定义一个整体类后，再去分析这个整体类的租场结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。</p>
<p>在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。</p>
<p><img src="https://img-blog.csdnimg.cn/20191229184245573.png"></p>
<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成。</p>
<p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    House house; </span><br><span class="line">    <span class="comment">//聚合关系中作为成员变量的类一般使用set方法赋值</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">        This.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setHouse</span><span class="params">(House house)</span></span>&#123;</span><br><span class="line">        This.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">driver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“车的型号：”+car.<span class="built_in">getType</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“我在房子里睡觉：”+house.<span class="built_in">getAddress</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合（整体和部分不能分开）"><a href="#组合（整体和部分不能分开）" class="headerlink" title="组合（整体和部分不能分开）"></a>组合（整体和部分不能分开）</h2><p>组合关系表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之 间具有同生共死的关系。</p>
<p>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。</p>
<p><img src="https://img-blog.csdnimg.cn/20191229184852279.png"></p>
<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成。</p>
<p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    Soul soul;</span><br><span class="line">    Body body; </span><br><span class="line">    <span class="comment">//组合关系中的成员变量一般会在构造方法中赋值</span></span><br><span class="line">     <span class="function">Public <span class="title">People</span><span class="params">(Soul soul, Body body)</span></span>&#123; </span><br><span class="line">        This.soul = soul;</span><br><span class="line">        This.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Public <span class="type">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“学习要用灵魂”+soul.<span class="built_in">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Public <span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(“吃饭用身体：”+body.<span class="built_in">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>1、依赖性区别</p>
<p>聚合中的两种类（或实体）是可以单独存在的，不会相互影响；被关联的一方可以独立于关联一方，依赖性不强。</p>
<p>相反，组合中的两个实体（或者类）是高度依赖于彼此的，它们之间会相互影响。</p>
<p>2、关系类型的区别</p>
<p>聚合代表了has-a关系，一种单向关系；组合代表了part-of关系。</p>
<p>3、关联强度的不同</p>
<p>聚合是一种弱关联关系；组合是一种强关联关系。</p>
<p>4、生命周期的不同</p>
<p>在聚合关系中的两个类（或实体）的生命周期是不同步；但，在组合关系中的两个类（或实体）的生命周期是同步的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="post-title-link" itemprop="url">拷贝构造和拷贝赋值</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-09 10:39:14 / 修改时间：10:39:27" itemprop="dateCreated datePublished" datetime="2022-06-09T10:39:14+08:00">2022-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43691639/article/details/124756222">(55条消息) 1. 拷贝构造、拷贝赋值、析构_Simple_667的博客-CSDN博客_拷贝构造 拷贝赋值</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C++智能指针</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 09:43:16" itemprop="dateCreated datePublished" datetime="2022-06-09T09:43:16+08:00">2022-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">深拷贝和浅拷贝</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-08 22:58:56" itemprop="dateCreated datePublished" datetime="2022-06-08T22:58:56+08:00">2022-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-09 09:08:47" itemprop="dateModified" datetime="2022-06-09T09:08:47+08:00">2022-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++中类的拷贝有两种：深拷贝和浅拷贝；当出现等号赋值时，即会调用拷贝函数</p>
<h2 id="一、深拷贝和浅拷贝的区别"><a href="#一、深拷贝和浅拷贝的区别" class="headerlink" title="一、深拷贝和浅拷贝的区别"></a>一、深拷贝和浅拷贝的区别</h2><p>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p>
<h2 id="二、解释"><a href="#二、解释" class="headerlink" title="二、解释"></a>二、解释</h2><p>浅拷贝就是对象的数据成员之间的简单复制。如果你设计了一个类而没有提供它的复制构造函数，当该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝。</p>
<p>然而当一个对象中有指针时，两个指针就会指向堆上的同一块内存，析构时就会对该内存释放两次。对同一块内存执行两次以上的释放结果时未定义的，所以这将导致内存泄漏或程序崩溃。</p>
<p>所以这里就需要深拷贝来解决这个问题。深拷贝就是当拷贝对象中有其他资源（如堆、文件、系统等）的指针或引用时，对象另开辟一块新的资源，而不再拷贝对象中堆其他资源的指针或引用进行单纯的赋值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/08/%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-Object-slicing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/p1.jpg">
      <meta itemprop="name" content="戎菜菜">
      <meta itemprop="description" content="hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小戎的学习历程">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/08/%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87-Object-slicing/" class="post-title-link" itemprop="url">对象切片(Object slicing)</a>
        </h2>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-08 21:57:10 / 修改时间：22:56:06" itemprop="dateCreated datePublished" datetime="2022-06-08T21:57:10+08:00">2022-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在C++编程中，将派生类类型（subclass type）的对象复制到基类类型（superclass）的对象时，将发生对象切片；基类副本将没有在派生类中定义的任何成员变量。实际上，这些变量已经被“分隔”。</p>
<p>更巧妙的是，当基类的赋值运算符将派生类类型的对象复制到相同类型的对象时，对象切片同样会发生，在这些情况下，目标对象的某些成员变量将保留其原始值，而不是从源对象复制过来。</p>
<h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_value&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value): m_value&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> value): Base&#123; value &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived&#123; <span class="number">5</span> &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;derived is a &quot;</span> &lt;&lt; derived.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; derived.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    Base &amp;ref&#123; derived &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref is a &quot;</span> &lt;&lt; ref.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; ref.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    Base *ptr&#123; &amp;derived &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ptr is a &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; and has value &quot;</span> &lt;&lt; ptr-&gt;<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，&amp;ref和*ptr指向派生对象，派生对象具有积累部分和派生部分。由于ref和ptr的类型为Base，因此ref和ptr只能看到derived的Base部分。</p>
<p>但是derived的Derived部分仍然存在，只是根本无法通过ref或ptr看到。但是没通过使用虚函数，我们可以访问函数的最衍生版本。因此，以上程序打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">derived is a Derived and has value 5</span><br><span class="line">ref is a Derived and has value 5</span><br><span class="line">ptr is a Derived and has value 5</span><br></pre></td></tr></table></figure>

<p><b>但是，如果我们仅将派生对象分配给基类对象，而不是派生对象的基类引用或指针，会发生什么情况呢？</b></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived derived&#123;<span class="number">5</span>&#125;;</span><br><span class="line">	Base base&#123;derived&#125;;<span class="comment">// what happens here?</span></span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;basee is a &quot;</span>&lt;&lt;base.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; and has value &quot;</span>&lt;&lt;base.<span class="built_in">getValue</span>()&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，派生类具有基类部分和派生部分。当我们将派生对象分配给基类对象时，仅复制派生对象的基类部分，而不复制派生部分。在上面的示例中，base接收了派生的Base部分的副本，但没有Derived部分。该派生部分已被有效地“sliced off”。因此，将派生类对象分配给基类对象称为对象切片。</p>
<p>因为变量base没有派生部分，所以<code>base.getName()</code>解析为<code>Base::getName()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base is a Base <span class="keyword">and</span> has value <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="Slicing-and-functions"><a href="#Slicing-and-functions" class="headerlink" title="Slicing and functions"></a>Slicing and functions</h4><p>现在，你可能会觉得上面的示例有点愚蠢，毕竟，你为什么要像这样分派派生给基础？你可能不会。但是，切片很可能会偶然发生在函数上。</p>
<p>考虑以下功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> Base base)</span> <span class="comment">//note: base passed by value,not reference</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;I am a &quot;</span>&lt;&lt;base.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个非常简单的函数，带有const基础对象参数，该参数按值传递。如果我们这样调用此函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derived d&#123;<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">printName</span>(d);<span class="comment">//oops,didn&#x27;t realize this way pass by value on the calling end</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写该程序时，你可能没有注意到base是一个值函数，而不是引用。因此，当调用<code>printName(d)</code>，我们可能期望<code>base.getName()</code>调用virtual函数<code>getName()</code>并显示“I am a Derived”，但是它没有发生。相反，派生对象d被切片并且仅将基类部分复制到基类参数中。执行<code>base.getName()</code>时，即使&#96;&#96;getName()&#96;函数已被虚拟化，该类也没有派生部分可以解析。因此，该程序将打印：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am a Base</span><br></pre></td></tr></table></figure>

<p>当然，修改方法是通过将函数参数作为引用而不是按值传递（这也是按引用而不是按值传递类参数是个好主意的另一个原因），可以轻松避免在此处切片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(<span class="type">const</span> Base &amp;base)</span> <span class="comment">//note: base now passed by reference</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am a Derived</span><br></pre></td></tr></table></figure>

<h4 id="Slicing-vectors"><a href="#Slicing-vectors" class="headerlink" title="Slicing vectors"></a>Slicing vectors</h4><p>新程序员在切片方面遇到麻烦的另一个领域是尝试使用<code>std :: vector</code>实现多态。考虑以下程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Base&gt; v&#123;&#125;;  <span class="comment">// std :: vector 被声明为 Base类型的向量</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(Base&#123; <span class="number">5</span> &#125;); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(Derived&#123; <span class="number">6</span> &#125;); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : v)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;I am a &quot;</span> &lt;&lt; element.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; element.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value 5</span><br><span class="line">I am a Base with value 6</span><br></pre></td></tr></table></figure>

<p>与前面的示例相似，因为<code>std :: vector</code>被声明为<code>Base</code>类型的向量，所以当将<code>Derived（6）</code>添加到该向量时，将其切片。</p>
<p>解决这个问题要困难一些。许多新程序员尝试创建对对象的引用的<code>std :: vector</code>，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Base*&gt; v&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	Base b&#123; <span class="number">5</span> &#125;; <span class="comment">// b and d can&#x27;t be anonymous objects</span></span><br><span class="line">	Derived d&#123; <span class="number">6</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;b); <span class="comment">// add a Base object to our vector</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;d); <span class="comment">// add a Derived object to our vector</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Print out all of the elements in our vector</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>* element : v)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;I am a &quot;</span> &lt;&lt; element-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; element-&gt;<span class="built_in">getValue</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am a Base with value <span class="number">5</span></span><br><span class="line">I am a Derived with value <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>哪个有效? 有关于此的一些评论。首先，nullptr现在是一个有效的选项，可能不希望如此。其次，您现在必须处理指针语义，这可能很尴尬。但是从好的方面来说，这也允许动态内存分配，如果您的对象可能超出范围，这将很有用。</p>
<h4 id="The-Frankenobject"><a href="#The-Frankenobject" class="headerlink" title="The Frankenobject"></a>The Frankenobject</h4><p>在上面的示例中，我们看到了由于划分出派生类而导致切片导致错误结果的情况。现在，让我们看一下派生对象仍然存在的另一种危险情况！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived d1&#123;<span class="number">5</span>&#125;;</span><br><span class="line">	Derived d2&#123;<span class="number">6</span>&#125;;</span><br><span class="line">	Base &amp;b&#123;d2&#125;;</span><br><span class="line">	</span><br><span class="line">	b = d1;<span class="comment">//this line is problematic</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的前三行非常简单。创建两个”派生“对象， 并将”base”引用设置为第二个。第四行是误入歧途的地方。</p>
<p>如果b是派生的话，由于b指向d2，我们将d1分配给b，你可能会认为结果是将d1将被复制到d2中。但b是一个基类对象，默认情况下C++为类提供的<code>operator =</code>不是virtual的。因此，只有d1的基本部分被复制到d2中。</p>
<p>结果，你将发现d2现在具有d1的基类部分和d2本身的派生部分，创建出一个<code>Frankenobject</code>（它由多个对象的一部分组成）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="戎菜菜"
      src="/images/p1.jpg">
  <p class="site-author-name" itemprop="name">戎菜菜</p>
  <div class="site-description" itemprop="description">hey</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">戎菜菜</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

</html>
